/*
 * look up a keyword in a table
 *
 * the architecture of this is to have a brutally fast, tight lexer
 * that does minimal searching and uses little memory. 
 * building the lexer table is manual and critical, so adding keywords
 * needs to be carefully done.
 *
 * we have 2 different tables to use, one for C, one for cpp.
 *
 * each table is an array of characters, with the following grammar:
 * byte:
 * 0xff <token number>		if the input string is at null,
 *				return token, else 0;
 * 0xfe <token number>		if the input string is at null,
 *				return token, else advance to next
 *				pattern
 * <character>			if string matches character, advance
 *				both. else return 0
 * <character|0x80> <skip>	if string matches low 7 bits, advance
 *				string by 1 and pattern by 2. if not,
 *				advance pattern by skip
 */
#include "cpp.h"

#define	HI	0x80

/*
 * the C pre-processor
 */
unsigned char cppkw[] = {
    'd', 'e', 'f', 'i', 'n', 'e', 0xff, DEFINE,
    'e'|HI, 17, 'l'|HI, 9, 's'|HI, 3, 'e', 0xff, ELSE,
            'i', 'f', 0xff, ELIF,
        'n', 'd', 'i', 'f', 0xff, ENDIF,
    'i'|HI, 25, 'f'|HI, 15, 0xfe, IF,
            'd'|HI, 4, 'e', 'f', 0xff, IFDEF,
            'n'|HI, 5, 'd', 'e', 'f', 0xff, IFNDEF,
        'n', 'c', 'l', 'u', 'd', 'e', 0xff, INCLUDE,
    'u', 'n', 'd', 'e', 'f', 0xff, UNDEF,
    0   /* end of table */
};

/*
 * C keyword table (ckw[]) is generated by mkkw into kwtab.c
 * It uses skip-optimization for fast lookup.
 */

#ifdef ASMKWLOOK
/*
 * Look up keyword in compressed table (Z80 assembly implementation)
 *
 * Hand-optimized Z80 assembly implementation of keyword table lookup.
 * This version provides maximum performance and minimum code size for
 * the Z80 target platform.
 *
 * Algorithm:
 *   - Pattern matching using compressed table grammar
 *   - Processes HI bit characters (skip pointers) for fast mismatches
 *   - Follows character sequences for potential matches
 *   - Returns token number if complete match, 0 otherwise
 *
 * Table grammar (defined in file header comments):
 *   0xff <token> - If string at null, return token, else 0
 *   0xfe <token> - If string at null, return token, else advance pattern
 *   <char>       - If matches, advance both, else return 0
 *   <char|0x80> <skip> - If matches low 7 bits, advance both by 2, else skip
 *
 * Register usage:
 *   HL - Table pointer
 *   DE - String pointer
 *   A  - Working register
 *
 * Parameters:
 *   str   - Null-terminated keyword string to search for
 *   table - Compressed keyword table (cppkw or ckw)
 *
 * Returns:
 *   Token number if found, 0 if not found
 *
 * Side effects:
 *   - Modifies Z80 registers (HL, DE, A, flags)
 *   - No side effects to memory or global state
 */

char *kw_table;
char *kw_string;
unsigned kw_ret;

char
kwlook(char *str, char *table)
{
    kw_string = str;
    kw_table = table;

    asm {
        ld hl,(_kw_table)
        ld de,(_kw_string)
        jr done_p;
    lp:
    top:
        ld a,(hl)
        cp a,0xff
        jr nz,not_term
        inc hl
        ld a,(de)
        or a,a
        ld a,0
        jr nz,fin
    ret_tok:
        ld a,(hl)
        jr fin
    not_term:
        cp a,0xfe
        jr nz,cond
        inc hl
        ld a,(de)
        or a,a
        jr z,ret_tok;
        inc hl
        jr lp
    cond:
        bit 7,a
        jr z,liter
        res 7,a
        ex de,hl
        cp a,(hl)
        ex de,hl
        jr nz,skip
        inc hl
        jr next;
    skip:
        inc hl
        ld a,(hl);
        add a,2
        add a,l
        ld l,a;
        ld a,0
        adc a,h
        ld h,a
        jr lp
    liter:
        cp a,(hl)
        ld a,0
        jr nz,fin
    next:
        inc hl
        inc de
    done_p:
        ld a,(de)
        or a,a
        jr nz, top
    fin:
        ld (_kw_ret), a
    }
    return kw_ret;
}

#else
/*
 * Look up keyword in compressed table (portable C implementation)
 *
 * Searches a compressed keyword table for a given identifier string.
 * Uses a space-efficient table encoding with skip pointers for fast
 * mismatch rejection. This is the portable C version used on non-Z80
 * platforms.
 *
 * Table compression:
 *   - Characters with HI bit set (0x80) include skip distance
 *   - Skip distance allows jumping past unmatched prefix trees
 *   - Terminators (0xff, 0xfe) signal end of pattern with token
 *
 * Algorithm:
 *   - Walk pattern and string in parallel
 *   - HI bit characters: match low 7 bits, advance by 2 or skip
 *   - Literal characters: must match exactly
 *   - Terminators: check if string also at end
 *
 * Table grammar examples (from header):
 *   Simple match: 'd', 'o', 0xff, DO
 *   With skip: 'i'|HI, 7, 'f'|HI, 15, 0xfe, IF, ...
 *
 * Used for:
 *   - C keyword lookup (ckw table): if, while, int, etc.
 *   - CPP keyword lookup (cppkw table): define, ifdef, include
 *
 * Parameters:
 *   str   - Null-terminated identifier string to search for
 *   table - Compressed keyword table (cppkw or ckw)
 *
 * Returns:
 *   Token number if keyword found, 0 if not found (identifier)
 *
 * Side effects:
 *   - None (pure function)
 */
/*
 * Returns keyword value on match, 0xff on no match.
 * Handles both simple table format and skip-optimized format.
 * Table ends with single 0 byte (not 0xff,0 since KW_INT=0).
 */
unsigned char
kwlook(unsigned char *str, unsigned char *table)
{
	unsigned char c;
	unsigned char *s = str;

	while (1) {
		c = *table;
		if (c == 0) {
			return 0xff;  /* end of table, no match */
		}
		if (c == 0xff || c == 0xfe) {
			/* end of entry - check if string is consumed */
			if (*s == 0) {
				return table[1];  /* match! */
			}
			/* string not consumed */
			table += 2;
			if (c == 0xff) {
				/* 0xff = end of entry, try next entry (reset s) */
				s = str;
			}
			/* 0xfe = prefix matched, continue to longer patterns (keep s) */
			continue;
		}
		if (c & 0x80) {
			/* HI byte with skip (for skip-optimized tables) */
			if (*s == (c & 0x7f)) {
				s++;
				table += 2;
			} else {
				/* skip to sibling - stay at same depth, don't reset s */
				table += table[1] + 2;
			}
			continue;
		}
		/* literal character match */
		if (c != *s) {
			/* mismatch - skip to end of this entry */
			while (*table != 0xff && *table != 0xfe && *table != 0) {
				if (*table & 0x80) {
					/* skip over HI byte and skip value */
					table += 2;
				} else {
					table++;
				}
			}
			/* at end of table? */
			if (*table == 0) {
				return 0xff;
			}
			/* skip past terminator and value */
			table += 2;
			s = str;  /* reset string pointer */
			continue;
		}
		s++;
		table++;
	}
}
#endif

/* vim: set tabstop=4 shiftwidth=4 noexpandtab: */
