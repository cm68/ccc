# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is **ccc** - a native C compiler written in C, currently under reconstruction. The source was retyped from a paper printout with missing chunks. This is a 2-pass compiler:

1. **Pass 1** (cc1): Recursive descent parser with embedded C preprocessor (CPP) - parses and validates C code
2. **Pass 2** (cc2): Code generator and assembler - writes object file (not yet implemented)

**Current Status**: Pass 1 is substantially complete with ~4,600 lines of C code. The compiler successfully parses C code including preprocessor directives, declarations, types, expressions, and statements.

## Build Commands

```bash
# Build the compiler (pass 1 only)
make

# Build specific targets
make cc1          # Main compiler executable

# Run tests
make test         # Run all 95+ tests in tests/
make tests        # Same as 'make test'

# Run test categories
make test-typedef # Run typedef tests only
make test-sizeof  # Run sizeof tests only
make test-cpp     # Run preprocessor tests only
# (See tests/Makefile for all categories)

# Run single test
cd tests && ./runtest.sh decl.c
cd tests && ./runtest.sh -v 3 decl.c  # With verbosity level 3

# Run unit tests
make unit-tests   # Run component-level unit tests

# Regenerate auto-generated files
make regen

# Clean build artifacts
make clean        # Remove objects and generated files
make clobber      # Remove all build artifacts including binaries

# Generate ctags
make tags
```

## Running the Compiler

```bash
# Basic usage
./cc1 [options] <source.c>

# Common options
./cc1 -E source.c              # Preprocessor only (outputs .i file)
./cc1 -I<dir> source.c         # Add include directory
./cc1 -D<var>=<val> source.c   # Define preprocessor variable
./cc1 -v <level> source.c      # Set verbosity level (hex bitmask)

# Debug with verbosity
./cc1 -v 0x3f -E tests/decl.c  # Maximum verbosity
```

## Architecture

### Code Organization

- **cc1.c**: Main entry point, command-line processing, file processing orchestration
- **lex.c**: Lexical analyzer (tokenizer) with embedded CPP support
- **parse.c**: Recursive descent parser for statements and declarations
- **expr.c**: Expression parsing with operator precedence and constant folding
- **type.c**: Type system - manages primitive types, pointers, arrays, functions, structs/unions/enums
- **declare.c**: Declaration parsing (variables, functions, types) including K&R style support
- **outast.c**: AST emission in S-expression format for pass 2 with memory width annotations
- **kw.c**: Keyword lookup tables (C keywords, CPP keywords, asm keywords)
- **io.c**: Character-level I/O, file stack management, macro expansion buffer
- **macro.c**: CPP macro definition and expansion
- **error.c**: Error reporting
- **util.c**: Utility functions (string ops, bit manipulation, fdprintf for Unix syscalls)

### Auto-Generated Files

The build system auto-generates several files from source code and data files. These should NOT be edited manually:

- **enumlist.h**: Generated from token.h, lists all token enum values for validation
- **tokenlist.c**: Generated by maketokens, contains token name arrays
- **error.h**: Generated from errorcodes via makeerror.awk, defines error codes and messages
- **debug.h**: Generated by makedebug.sh, extracts VERBOSE() tags from sources
- **debugtags.c**: Generated by makedebug.sh, verbose option descriptions
- **op_pri.h**: Generated by genop_pri, operator priority table for expression parsing

### Key Data Structures

**struct expr** (ccc.h:39-60): Expression tree nodes
- Contains operator, left/right/up/prev/next pointers for tree navigation
- Type information, variable reference, constant value
- Flags: E_CONST (constant expression), E_RESOLVED, E_FUNARG

**struct stmt** (ccc.h:79-95): Statement nodes
- Parent/next linkage, left/right expressions
- chain: child/body statement
- otherwise: else branch for if statements
- middle: middle expression for for-loops
- function: owning function reference
- Flags: S_PARENT, S_LABEL, S_FUNC
- Used for if/else/while/for/switch/case/return/goto/labels/blocks

**struct type** (ccc.h:153-161): Type descriptors
- name, size, count (for arrays)
- elem list (for struct/union members, function parameter types)
- sub (for pointers, arrays, function return types)
- Flags: TF_AGGREGATE, TF_INCOMPLETE, TF_UNSIGNED, TF_FUNC, TF_POINTER, TF_ARRAY, TF_FLOAT, TF_OLD

**struct name** (ccc.h:159-178): Symbol table entries
- Represents variables, typedefs, function names, struct/union/enum tags
- Contains type pointer, visibility, storage class, offset (for struct members)
- body: function body statement tree
- kind enum: prim, etag, stag, utag, var, elem, tdef
- Scope management via lexical level

### Type System Design

The type system is designed to be "squeaky-clean" with zero redundancy:
- Two variables of the same type share the identical type pointer
- Types are unified in a global type list, searched before creating new types
- Basic types are pre-loaded at initialization (char, short, long, unsigned variants, void, boolean, float, double)
- Primitive type indices: 0-2 are signed char/short/long, 3-5 are unsigned, 6+ are void/bool/float/double
- Type construction: pointers, arrays, functions are composed from subtypes
- Function types store parameter list in type->elem as a linked list of names

**Currently working**:
- Primitive type parsing (char, short, int, long, unsigned, void, boolean, float, double)
- Pointer types (int *p)
- Array types with sizes (int a[10]), including multi-dimensional arrays
- Function declarations with typed arguments (int foo(int a, char b))
- K&R style function declarations with parameter type defaulting to int
- Bitfield support in declarations
- Enum types with optional tag names (enum { A, B=5, C })
- Struct types with member lists (struct foo { int x; char y; })
- Union types (union bar { int i; float f; })
- Forward references for struct/union/enum tags (including typedef struct S S_t;)
- Tag namespace separate from variable namespace
- Struct member namespace separation from global namespace
- Typedef declarations (global and scoped inside functions)
- Typedef shadowing in nested scopes

**Not yet implemented**:
- Type compatibility checking (sametype)

### Function Parameter Architecture

Function parameters are handled with proper separation between type signatures and actual parameter symbols:

**Function Type Signature** (type->elem):
- Contains parameter types (stored as name entries with types)
- Parameter names are kept in type->elem for K&R type matching convenience
- Function type comparison uses `compatible_function_types()` which ignores names
- Two functions with same parameter types but different names have same type signature

**Function Parameter Symbols** (namespace at level 2):
- When parsefunc() processes a function body, it:
  1. Pushes a new scope (lexlevel becomes 2)
  2. Reads parameter info from type->elem
  3. Creates NEW name entries at level 2 with V_FUNARG flag
  4. Function body references parameters from level 2 namespace
  5. Dumps function output while params are still visible
  6. Pops scope (removes parameters from names[])

**Benefits of this design**:
- Function types properly normalized (names don't affect type compatibility)
- Parameters are regular symbols at level 2 in namespace (no special cases)
- Forward declarations with different parameter names work correctly
- dump_function() shows both type signature (types only) and actual parameters (with names)

**Example**:
```c
int foo(int x);           // Forward declaration
int foo(int y) { }        // Definition with different name - works!
```
Both have same function type (int -> int), but function body sees parameter as 'y' at level 2.

### Scope Management

Lexical scope is managed via a simple stack-based system:
- names[] array holds all name entries
- Each name has a 'level' field (0=basic types, 1=global, 2+=inner blocks)
- push_scope() increments lexlevel
- pop_scope() decrements lexlevel and removes all names at higher levels
- Lookup searches from most recent (highest index) to oldest

### Expression Parsing

Expression parsing uses precedence climbing:
- parse_expr(priority, stmt) recursively parses expressions
- Lower priority numbers bind tighter (higher precedence)
- op_pri[] table maps operators to priorities (auto-generated in op_pri.h)
- Constant folding (cfold) is performed during parsing for compile-time evaluation
- Precedence comparison: `p >= pri` stops parsing when encountering same/lower precedence
- Recursive call uses `parse_expr(p, st)` for right operand, ensuring left-associativity

**Currently working**:
- Numeric literals and constants
- String literals (stored in string table)
- Parenthesized expressions
- Variable references (SYM wrapped in DEREF for address semantics)
- Function and array name decay to pointers (correct C semantics)
- Unary operators: - (NEG), ~ (TWIDDLE), ! (BANG), * (DEREF), & (address-of)
- Binary operators: +, -, *, /, %, &, |, ^, <<, >> with proper precedence and left-associativity
- Logical operators: && (LAND), || (LOR)
- Assignment operator: = (with proper lvalue handling)
- Array subscript: [] with scaled address arithmetic
- Struct member access: . (DOT) and -> (ARROW) with offset addition
- Function calls with argument lists
- sizeof operator (for types and expressions)
- Ternary conditional operator: ?: with right-associativity
- Constant folding for all operators including ternary
- Operator precedence correctly implemented
- Address semantics: SYM nodes represent addresses, DEREF accesses values

**Not yet implemented**:
- Comparison operators in constant folding (<, >, <=, >=, ==, !=)
- Type casts
- Prefix/postfix increment/decrement (++/--)
- Compound assignment operators (+=, -=, etc.)

### Ternary Conditional Operator

The ternary conditional operator (? :) is fully implemented with proper right-associativity and constant folding:

**AST Structure**:
- Tree: `QUES(condition, COLON(true_expr, false_expr))`
- COLON is not a binary operator, only used as part of ternary
- COLON removed from operator priority table to prevent standalone use

**Parsing**:
- Triggered by QUES token in binary operator loop
- Parse true expression: `parse_expr(0)` allows any expression
- Expect and consume COLON token
- Parse false expression: `parse_expr(0)` for right-associativity
- Nested ternary operators allowed

**Right-Associativity**:
- `a ? b : c ? d : e` parses as `a ? b : (c ? d : e)`
- False branch can contain another ternary at same precedence level
- Example: `1 ? 2 : 0 ? 3 : 4` → `2` (not `3`)

**Constant Folding**:
- If condition is constant, fold to selected branch
- `1 ? 100 : 200` → `100`
- `0 ? 100 : 200` → `200`
- Handles nested constant ternary expressions

**Examples**:
```c
x > 0 ? 1 : -1          // (? (> x 0) (: 1 -1))
1 ? 10 : 20             // 10 (folded)
a ? b : c ? d : e       // (? a (: b (? c (: d e))))
```

**Label Compatibility**:
- Labels (`identifier:`) still work correctly
- Parsed at statement level by parse.c, not expression level
- Statement parser uses lookahead to detect label patterns
- Independent from expression operator handling

### Function and Array Decay

Functions and arrays automatically decay to pointers when used as values, following standard C semantics:

**Function Decay**:
- Function names represent addresses (function pointers)
- Function names are NOT wrapped in DEREF (unlike variables)
- Direct use: `funcname` → `$_funcname` (address)
- Assignment: `fptr = add;` → `(= $_fptr $_add)`
- Call through pointer: `fptr(5, 3);` → `(@ $_fptr 5 3)`
- Explicit address-of is redundant but allowed: `&add` → `(& $_add)`

**Array Decay**:
- Array names decay to pointer to first element
- Array names are NOT wrapped in DEREF (unlike variables)
- Direct use: `arr` → `$_arr` (address of first element)
- Assignment: `p = arr;` → `(= $_p $_arr)`
- Array subscript: `arr[5]` → `(M (+ $_arr 10))` (scaled offset, then deref)

**Variable Semantics (for comparison)**:
- Variables represent storage locations
- Variables ARE wrapped in DEREF to get their value
- Direct use: `x` → `(M $_x)` (dereference to get value)
- Assignment: `x = 10;` → `(= $_x 10)` (unwraps DEREF for lvalue)

**Implementation Details**:
The SYM case in expression parser checks type flags:
- If `TF_FUNC`: return SYM directly (function address)
- If `TF_ARRAY`: return SYM directly (array base address)
- Otherwise: wrap in DEREF (variable value)

**Function Pointer Arrays**:
Arrays of function pointers work with both syntaxes:

```c
int (*funcs[10])(int, int);

// Implicit syntax
result = funcs[0](5, 3);        // (@ (M (+ $_funcs 0)) 5 3)

// Explicit/preferred syntax
result = (*funcs[0])(5, 3);     // (@ (M (M (+ $_funcs 0))) 5 3)

// Variable index
result = (*funcs[i])(5, 3);     // (@ (M (M (+ $_funcs (* (M $i) 2)))) 5 3)

// Expression index
result = (*funcs[i+1])(5, 3);   // index expression evaluated and scaled
```

Both implicit and explicit syntaxes are supported and generate correct AST. The explicit syntax `(*funcs[x])(args)` is preferred and more clearly shows the dereference operation.

### Memory Width Annotations

The AST output includes memory width annotations on DEREF (M) and ASSIGN (=) operators to provide size information for code generation. This architectural decision enables several important benefits:

**Annotation Format**:
Size suffixes are appended to memory operations based on the type being accessed:
- `:b` - byte (1 byte: char)
- `:s` - short (2 bytes: short, int)
- `:l` - long (4 bytes: long)
- `:p` - pointer (2 bytes: any pointer type)
- `:f` - float (4 bytes: float)
- `:d` - double (8 bytes: double)

**Examples**:
```c
char c;
int i;
long l;

c = 10;              // (=:b $_c 10)
i = c;               // (=:s $_i (M:b $_c))
l = i;               // (=:l $_l (M:s $_i))
```

**Benefit 1: Deferred Type Checking to Pass 2**:
Size annotations allow pass 1 (cc1) to remain simple and focused on parsing, while pass 2 (cc2) handles all type width mismatches and conversions:

- Pass 1 just annotates the source and destination widths
- Pass 2 sees complete information: `(=:s $_i (M:b $a))` shows int←byte assignment
- Type conversions, sign extensions, and warnings are deferred to code generation time
- Pass 1 doesn't need complex type checking logic
- Pass 2 has full context to generate optimal conversion code

This separation of concerns keeps the parser clean and moves complexity to where it's needed (code generation).

**Benefit 2: Byte Arithmetic Optimization**:
Size annotations enable the code generator to use native byte arithmetic for byte-sized variables instead of promoting to word size:

```c
char a, b, c;
a = b + c;           // (=:b $a (+:b (M:b $b) (M:b $c)))
```

Without annotations, the code generator would need to:
1. Load b as byte, promote to word
2. Load c as byte, promote to word
3. Add words
4. Truncate result to byte
5. Store byte

With annotations, the code generator can:
1. Load b as byte
2. Add c as byte (native byte arithmetic)
3. Store a as byte

This generates smaller, faster code and preserves correct overflow semantics for byte-sized operations. On Z80 architecture, this is particularly important as many instructions operate directly on 8-bit values.

**Implementation**:
The `get_size_suffix()` function in outast.c examines type flags and size fields:
- Checks `TF_POINTER` flag for pointers
- Checks `TF_FLOAT` flag for float vs long disambiguation
- Uses `type->size` to determine width for other types

### Statement Parsing

Statement parsing is now active in parse.c:
- parsefunc() calls statement() to parse function bodies
- statement() processes statements recursively until END token
- Returns complete statement tree attached to function's body field

**Currently working**:
- Empty function bodies
- Block statements with scope management
- if/else statements
- while, do-while, for loops
- switch/case/default statements
- break, continue statements
- return statements (with and without expressions)
- goto and labels
- Expression statements
- Local variable declarations inside function bodies
- Typedef declarations inside function bodies (scoped)

**All statement types working**

### Token System

Tokens are encoded as single-byte values for efficient serialization:
- Most C keywords map to printable ASCII letters (IF='I', WHILE='W', etc.)
- Operators use their ASCII symbols where possible (PLUS='+', STAR='*')
- This allows cheap debugging and intermediate file I/O

### Debugging

Verbose debugging uses bitmask flags defined by VERBOSE() macro calls:
- Use -v flag with hex value to enable specific debug output
- ./makedebug.sh scans sources for VERBOSE(tag) and generates debug.h/debugtags.c
- Tags include: V_TRACE, V_LEX, V_PARSE, V_TYPE, etc.

## Development Notes

### Current State

The compiler has made substantial progress:

**Preprocessor (Complete)**:
- Macro definition and expansion
- #include directive handling
- Stringify (#) and token pasting (##) operators
- Conditional compilation (#if, #ifdef, #ifndef, #else, #endif)
- Macro expansion with argument substitution

**Lexer (Complete)**:
- Tokenization of all C keywords and operators
- Numeric literal parsing
- String literal handling
- Character constants
- Embedded preprocessor integration

**Type System (Substantially Complete)**:
- Primitive type parsing with all modifiers
- Pointer types (multi-level)
- Array types (multi-dimensional)
- Function types with parameter lists
- Struct, union, enum declarations
- Forward references and incomplete types
- Tag namespace separation
- Struct member namespace separation

**Declaration Parsing (Complete)**:
- Variable declarations (global and local)
- Function declarations (both ANSI and K&R style)
- ANSI-style function definitions: `int foo(int x) { }` works correctly
- K&R style function definitions with parameter type declarations
- Undeclared K&R parameters default to int
- Forward declarations with different parameter names supported
- Function type normalization: parameter names don't affect type compatibility
- Typedef declarations (global and scoped inside functions)
- Bitfield declarations
- Storage class specifiers
- Initializer expressions (basic support)

**Expression Parsing (Functional)**:
- All unary operators with constant folding
- All binary operators with constant folding
- Proper operator precedence and associativity
- Parenthesized expressions
- Numeric constant expressions

**Statement Parsing (Complete)**:
- Function body parsing enabled
- All control flow statements (if/else, while, do-while, for, switch/case)
- Jump statements (break, continue, return, goto/labels)
- Block statements with proper scoping
- Local variable and typedef declarations inside function bodies
- Statement trees attached to function bodies

**Memory Management**:
- Fixed major memory leaks in declaration parsing
- Proper cleanup in pop_scope()
- Valgrind clean on basic tests (no definite leaks)

**Not yet implemented**:
- Symbol table integration for expression evaluation
- Type checking and validation
- Code generation (pass 2)

### Known Issues

- The 'signed' keyword is not supported (deliberate omission)
- Anonymous struct/union declarations don't work properly
- Single-bit bitfields in structs could be optimized better

### Testing

Tests are in tests/ directory (108 tests organized by category):
- **Expression tests** (EXPR_TESTS): Constant folding, simple expressions
- **Declaration tests** (DECL_TESTS): Variable and type declarations
- **Preprocessor tests** (CPP_TESTS): Macros, includes, conditional compilation, stringify
- **K&R function tests** (KR_FUNC_TESTS): K&R style function definitions
- **Modern function tests** (FUNC_TESTS): ANSI-style definitions and prototypes, forward declarations
- **Statement tests** (STMT_TESTS): All control flow statements
- **sizeof tests** (SIZEOF_TESTS): sizeof operator with various types
- **Typedef tests** (TYPEDEF_TESTS): Global and scoped typedefs, forward declarations
- **Local variable tests** (LOCAL_TESTS): Local declarations in functions
- **Scope tests** (SCOPE_TESTS): Lexical scoping
- **Struct tests** (STRUCT_TESTS): Struct declarations
- **Type cast tests** (CAST_TESTS): Pointer-to-pointer, scalar, and mixed casts with typedef support
- **Minimal/smoke tests**: Basic compiler functionality
- **Miscellaneous tests**: Regression tests

Unit tests are in unit_test/ directory:
- **test_kw**: Keyword lookup table testing
- **test_insertmacro**: Macro text insertion testing

See tests/Makefile for complete test organization and tests/README.md for documentation.

Tests run with:
- `make test` - Run all integration tests
- `make test-typedef` - Run typedef tests only
- `make test-cast` - Run type cast tests only
- See tests/Makefile for all test categories
- `make unit-tests` - Run unit tests
- `cd tests && ./runtest.sh name.c` - Run single test
- Tests pass if cc1 completes without crashing

### Recent Improvements

1. **AST emission for pass 2** - Complete S-expression output with single-char operators
2. **Global variable initializers** - Arrays, structs, scalar initializers in AST
3. **Unix syscall migration** - fdprintf() replaces fprintf(), uses write() instead of stdio
4. **Removed MAXTRACE debug code** - Eliminated 192 lines of stderr debug traces
5. **Typedef support** - Global and scoped typedefs inside functions with proper shadowing
6. **Local variable declarations** - Full support for declarations inside function bodies
7. **Test infrastructure** - 95+ tests organized into 12 categories in tests/Makefile
8. **Memory leak fixes** - Valgrind clean on all tests
9. **K&R function support** - Full K&R style function definitions
10. **Comprehensive preprocessor** - Macros, includes, conditional compilation, stringify, token pasting

### Code Style

- Minimize code size, even at some cost to clarity