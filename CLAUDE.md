# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is **ccc** - a native C compiler written in C, currently under reconstruction. The source was retyped from a paper printout with missing chunks, so it's very far from working. This is a 2-pass compiler:

1. **Pass 1** (cc1): Recursive descent parser with embedded C preprocessor (CPP) - writes ASCII parse tree file
2. **Pass 2** (cc2): Code generator and assembler - writes object file (not yet implemented)

## Build Commands

```bash
# Build the compiler (pass 1 only)
make

# Build specific targets
make cc1          # Main compiler executable
make lextest      # Lexer testing binary

# Run tests
make test         # Run all tests in tests/
make tests        # Same as 'make test'

# Run single test
./runtest.sh tests/decl.c
./runtest.sh -v 3 tests/decl.c  # With verbosity level 3

# Regenerate auto-generated files
make regen

# Clean build artifacts
make clean        # Remove objects and generated files
make clobber      # Remove all build artifacts including binaries

# Generate ctags
make tags
```

## Running the Compiler

```bash
# Basic usage
./cc1 [options] <source.c>

# Common options
./cc1 -E source.c              # Preprocessor only (outputs .i file)
./cc1 -I<dir> source.c         # Add include directory
./cc1 -D<var>=<val> source.c   # Define preprocessor variable
./cc1 -v <level> source.c      # Set verbosity level (hex bitmask)

# Debug with verbosity
./cc1 -v 0x3f -E tests/decl.c  # Maximum verbosity
```

## Architecture

### Code Organization

- **cc1.c**: Main entry point, command-line processing, file processing orchestration
- **lex.c**: Lexical analyzer (tokenizer) with embedded CPP support
- **parse.c**: Recursive descent parser for statements and declarations
- **expr.c**: Expression parsing with operator precedence and constant folding
- **type.c**: Type system - manages primitive types, pointers, arrays, functions, structs/unions/enums
- **declare.c**: Declaration parsing (variables, functions, types)
- **kw.c**: Keyword lookup tables (C keywords, CPP keywords, asm keywords)
- **io.c**: Character-level I/O, file stack management, macro expansion buffer
- **macro.c**: CPP macro definition and expansion
- **error.c**: Error reporting
- **util.c**: Utility functions (string ops, bit manipulation, hex dump)

### Auto-Generated Files

The build system auto-generates several files from source code and data files. These should NOT be edited manually:

- **enumlist.h**: Generated from token.h, lists all token enum values for validation
- **tokenlist.c**: Generated by maketokens, contains token name arrays
- **error.h**: Generated from errorcodes via makeerror.awk, defines error codes and messages
- **debug.h**: Generated by makedebug.sh, extracts VERBOSE() tags from sources
- **debugtags.c**: Generated by makedebug.sh, verbose option descriptions
- **op_pri.h**: Generated by genop_pri, operator priority table for expression parsing

### Key Data Structures

**struct expr** (ccc.h:39-60): Expression tree nodes
- Contains operator, left/right/up/prev/next pointers for tree navigation
- Type information, variable reference, constant value
- Flags: E_CONST (constant expression), E_RESOLVED, E_FUNARG

**struct stmt** (ccc.h:79-87): Statement nodes
- Parent/next linkage, left/right expressions
- Used for if/while/for/switch/return/etc

**struct type** (ccc.h:122-131): Type descriptors
- name, size, count (for arrays)
- elem list (for struct/union members)
- sub (for pointers, arrays, function return types)
- args (for function parameter types)
- Flags: TF_AGGREGATE, TF_INCOMPLETE, TF_UNSIGNED, TF_FUNC, TF_POINTER, TF_ARRAY, TF_FLOAT, TF_OLD

**struct name** (ccc.h:159-178): Symbol table entries
- Represents variables, typedefs, function names, struct/union/enum tags
- Contains type pointer, visibility, storage class, offset (for struct members)
- kind enum: prim, etag, stag, utag, var, elem, tdef
- Scope management via lexical level

### Type System Design

The type system is designed to be "squeaky-clean" with zero redundancy:
- Two variables of the same type share the identical type pointer
- Types are unified in a global type list, searched before creating new types
- Basic types are pre-loaded at initialization (char, short, long, unsigned variants, void, boolean, float, double)
- Primitive type indices: 0-2 are signed char/short/long, 3-5 are unsigned, 6+ are void/bool/float/double
- Type construction: pointers, arrays, functions are composed from subtypes
- Function types store argument list in type->elem as a linked list of names

**Currently working**:
- Primitive type parsing (char, short, int, long, unsigned, void, boolean, float, double)
- Pointer types (int *p)
- Array types with sizes (int a[10])
- Function declarations with typed arguments (int foo(int a, char b))
- Bitfield support in declarations
- Enum types with optional tag names (enum { A, B=5, C })
- Struct types with member lists (struct foo { int x; char y; })
- Union types (union bar { int i; float f; })
- Forward references for struct/union/enum tags
- Tag namespace separate from variable namespace

**Not yet implemented**:
- typedef
- Type compatibility checking (sametype)

### Scope Management

Lexical scope is managed via a simple stack-based system:
- names[] array holds all name entries
- Each name has a 'level' field (0=basic types, 1=global, 2+=inner blocks)
- push_scope() increments lexlevel
- pop_scope() decrements lexlevel and removes all names at higher levels
- Lookup searches from most recent (highest index) to oldest

### Expression Parsing

Expression parsing uses precedence climbing:
- parse_expr(priority, stmt) recursively parses expressions
- Lower priority numbers bind tighter (higher precedence)
- op_pri[] table maps operators to priorities (auto-generated in op_pri.h)
- Constant folding (cfold) is performed during parsing for compile-time evaluation
- Precedence comparison: `p >= pri` stops parsing when encountering same/lower precedence
- Recursive call uses `parse_expr(p, st)` for right operand, ensuring left-associativity

**Currently working**:
- Numeric literals
- Parenthesized expressions
- Unary operators: - (NEG), ~ (TWIDDLE), ! (BANG), * (DEREF), & (address-of)
- Binary operators with proper precedence and left-associativity
- Constant folding for basic arithmetic

**Not yet implemented**:
- Symbol/variable references (SYM case)
- String literals
- Type casts
- sizeof operator
- Prefix/postfix increment/decrement (++/--)
- Array indexing ([])
- Function calls
- Struct member access (. and ->)

### Token System

Tokens are encoded as single-byte values for efficient serialization:
- Most C keywords map to printable ASCII letters (IF='I', WHILE='W', etc.)
- Operators use their ASCII symbols where possible (PLUS='+', STAR='*')
- This allows cheap debugging and intermediate file I/O

### Debugging

Verbose debugging uses bitmask flags defined by VERBOSE() macro calls:
- Use -v flag with hex value to enable specific debug output
- ./makedebug.sh scans sources for VERBOSE(tag) and generates debug.h/debugtags.c
- Tags include: V_TRACE, V_LEX, V_PARSE, V_TYPE, etc.

## Development Notes

### Current State

The compiler is incomplete and non-functional:
- Most of parse.c statement parsing is disabled (#ifdef notdef blocks)
- expr.c has been cleaned up - basic expression parsing now works
- type.c has been cleaned up and now supports:
  - Function declarations with arguments
  - Enum, struct, and union types with full parsing
- typedef not yet implemented
- Function body parsing is stubbed out

### Known Issues (from TODO)

- The 'signed' keyword is not supported (deliberate omission)
- Anonymous enums don't work
- Nested macro expansion needs verification
- Single-bit bitfields in structs could be optimized better

### Testing

Tests are in tests/ directory:
- Tests are C source files
- runtest.sh runs cc1 with -E flag (preprocessor mode)
- Outputs .i file (preprocessed source)
- Currently only tests lexer/preprocessor, not full compilation
