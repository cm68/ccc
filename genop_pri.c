/*
 * generate operator priority table for expression parsing
 *
 * this program generates op_pri.h which contains:
 * - OP_MIN and OP_MAX constants defining the range of operator tokens
 * - op_pri[] array mapping token values to precedence levels
 *
 * precedence convention: LOWER numbers bind TIGHTER (higher precedence)
 * when parse_expr() is called with priority N, it stops parsing when it
 * encounters an operator with priority >= N
 */

#include <stdio.h>
#include "ccc.h"

struct oppri {
    int token;
    int priority;
} optable[] = {
    /* member access and postfix (handled specially in parser) */
    { DOT,      OP_PRI_PRIMARY },
    { DEREF,    OP_PRI_PRIMARY },

    /* multiplicative */
    { STAR,     OP_PRI_MULT },
    { DIV,      OP_PRI_MULT },
    { MOD,      OP_PRI_MULT },

    /* additive */
    { PLUS,     OP_PRI_ADD },
    { MINUS,    OP_PRI_ADD },

    /* shift */
    { LSHIFT,   OP_PRI_SHIFT },
    { RSHIFT,   OP_PRI_SHIFT },

    /* relational */
    { LT,       OP_PRI_REL },
    { GT,       OP_PRI_REL },
    { LE,       OP_PRI_REL },
    { GE,       OP_PRI_REL },

    /* equality */
    { EQ,       OP_PRI_EQUAL },
    { NEQ,      OP_PRI_EQUAL },

    /* bitwise and */
    { AND,      OP_PRI_BITAND },

    /* bitwise xor */
    { XOR,      OP_PRI_BITXOR },

    /* bitwise or */
    { OR,       OP_PRI_BITOR },

    /* logical and */
    { LAND,     OP_PRI_LOGAND },

    /* logical or */
    { LOR,      OP_PRI_LOGOR },

    /* conditional - special handling needed for : */
    { QUES,     OP_PRI_COND },
    { COLON,    OP_PRI_COND },

    /* assignment operators */
    { ASSIGN,   OP_PRI_ASSIGN },
    { PLUSEQ,   OP_PRI_ASSIGN },
    { SUBEQ,    OP_PRI_ASSIGN },
    { MULTEQ,   OP_PRI_ASSIGN },
    { DIVEQ,    OP_PRI_ASSIGN },
    { MODEQ,    OP_PRI_ASSIGN },
    { ANDEQ,    OP_PRI_ASSIGN },
    { OREQ,     OP_PRI_ASSIGN },
    { XOREQ,    OP_PRI_ASSIGN },
    { LSHIFTEQ, OP_PRI_ASSIGN },
    { RSHIFTEQ, OP_PRI_ASSIGN },
    { LANDEQ,   OP_PRI_ASSIGN },
    { LOREQ,    OP_PRI_ASSIGN },

    /* comma */
    { COMMA,    OP_PRI_COMMA },

    { 0, 0 }    /* sentinel */
};

int
main(int argc, char **argv)
{
    int i;
    int min = 255, max = 0;
    int op;
    FILE *fp;

    /* find min and max operator token values */
    for (i = 0; optable[i].token != 0; i++) {
        op = optable[i].token;
        if (op < min) min = op;
        if (op > max) max = op;
    }

    fp = fopen("op_pri.h", "w");
    if (!fp) {
        perror("op_pri.h");
        return 1;
    }

    fprintf(fp, "/*\n");
    fprintf(fp, " * operator priority table - AUTO GENERATED by genop_pri\n");
    fprintf(fp, " * DO NOT EDIT THIS FILE MANUALLY\n");
    fprintf(fp, " *\n");
    fprintf(fp, " * precedence: lower numbers bind tighter (higher precedence)\n");
    fprintf(fp, " * when parse_expr(N) encounters operator with priority >= N, it stops\n");
    fprintf(fp, " */\n\n");

    fprintf(fp, "#define OP_MIN %d\n", min);
    fprintf(fp, "#define OP_MAX %d\n", max);
    fprintf(fp, "\n");

    fprintf(fp, "static char op_pri[] = {\n");

    /* generate array indexed by (token - OP_MIN) */
    for (op = min; op <= max; op++) {
        int pri = OP_PRI_NONE;

        /* lookup this token in our table */
        for (i = 0; optable[i].token != 0; i++) {
            if (optable[i].token == op) {
                pri = optable[i].priority;
                break;
            }
        }

        fprintf(fp, "    %2d,  /* %3d 0x%02x", pri, op, op);
        if (op >= ' ' && op <= '~') {
            fprintf(fp, " '%c'", op);
        }

        /* add comment with operator name if found */
        if (pri != OP_PRI_NONE) {
            fprintf(fp, " - ");
            switch (op) {
            case DOT:      fprintf(fp, "DOT"); break;
            case DEREF:    fprintf(fp, "DEREF"); break;
            case STAR:     fprintf(fp, "STAR"); break;
            case DIV:      fprintf(fp, "DIV"); break;
            case MOD:      fprintf(fp, "MOD"); break;
            case PLUS:     fprintf(fp, "PLUS"); break;
            case MINUS:    fprintf(fp, "MINUS"); break;
            case LSHIFT:   fprintf(fp, "LSHIFT"); break;
            case RSHIFT:   fprintf(fp, "RSHIFT"); break;
            case LT:       fprintf(fp, "LT"); break;
            case GT:       fprintf(fp, "GT"); break;
            case LE:       fprintf(fp, "LE"); break;
            case GE:       fprintf(fp, "GE"); break;
            case EQ:       fprintf(fp, "EQ"); break;
            case NEQ:      fprintf(fp, "NEQ"); break;
            case AND:      fprintf(fp, "AND"); break;
            case XOR:      fprintf(fp, "XOR"); break;
            case OR:       fprintf(fp, "OR"); break;
            case LAND:     fprintf(fp, "LAND"); break;
            case LOR:      fprintf(fp, "LOR"); break;
            case QUES:     fprintf(fp, "QUES"); break;
            case COLON:    fprintf(fp, "COLON"); break;
            case ASSIGN:   fprintf(fp, "ASSIGN"); break;
            case PLUSEQ:   fprintf(fp, "PLUSEQ"); break;
            case SUBEQ:    fprintf(fp, "SUBEQ"); break;
            case MULTEQ:   fprintf(fp, "MULTEQ"); break;
            case DIVEQ:    fprintf(fp, "DIVEQ"); break;
            case MODEQ:    fprintf(fp, "MODEQ"); break;
            case ANDEQ:    fprintf(fp, "ANDEQ"); break;
            case OREQ:     fprintf(fp, "OREQ"); break;
            case XOREQ:    fprintf(fp, "XOREQ"); break;
            case LSHIFTEQ: fprintf(fp, "LSHIFTEQ"); break;
            case RSHIFTEQ: fprintf(fp, "RSHIFTEQ"); break;
            case LANDEQ:   fprintf(fp, "LANDEQ"); break;
            case LOREQ:    fprintf(fp, "LOREQ"); break;
            case COMMA:    fprintf(fp, "COMMA"); break;
            }
        }

        fprintf(fp, " */\n");
    }

    fprintf(fp, "};\n");

    fclose(fp);

    printf("Generated op_pri.h with %d entries (tokens %d to %d)\n",
           max - min + 1, min, max);

    return 0;
}

/*
 * vim: tabstop=4 shiftwidth=4 expandtab:
 */
