# CCC Runtime Library

This directory contains the Z80 assembly runtime library for programs compiled with the ccc compiler.

## Overview

The runtime library (`ccclib.s`) provides essential helper functions that support C language features on the Z80 processor. These functions are called by code generated by the cc2 code generator.

## Build System

- **Assembler**: z80asm
- **Build**: `make` to assemble object files
- **Clean**: `make clean` to remove generated files

## Runtime Functions

### Stack Frame Management

#### `framealloc`
Allocates a stack frame for a function.
- **Input**: A register contains frame size in bytes
- **Effect**: Allocates space on stack, sets up IY frame pointer
- **Used by**: Function prologues

#### `framefree`
Deallocates a stack frame and returns from function.
- **Input**: None (uses IY frame pointer)
- **Effect**: Frees stack frame, restores caller's frame pointer, returns
- **Used by**: Function epilogues (via `jp framefree`)

### Stack Frame Access

#### `indexiy`
Indexes the IY register by a signed byte offset.
- **Input**: A register contains signed offset (-128 to +127)
- **Output**: IY points to IY + offset
- **Preserves**: All registers except DE (used temporarily)
- **Cycles**: 11 bytes, ~20 cycles
- **Used by**: Other runtime functions

#### `leaiy`
Takes the address of a stack frame variable.
- **Input**: A register contains signed offset from IY
- **Output**: HL contains address of (IY + offset)
- **Preserves**: IY, DE
- **Used by**: Taking address of local variables (`&var`)

### Long (32-bit) Operations

#### `putlong`
Writes a 32-bit long value to the stack frame.
- **Input**:
  - A register: signed offset from IY
  - HL'HL: 32-bit value to write (HL=low word, HL'=high word)
- **Effect**: Stores 4 bytes at (IY + offset)
- **Byte order**: Little-endian (low byte at lowest address)
- **Used by**: Local long variable stores

#### `getlong`
Reads a 32-bit long value from the stack frame.
- **Input**: A register contains signed offset from IY
- **Output**: HL'HL contains 32-bit value (HL=low word, HL'=high word)
- **Byte order**: Little-endian
- **Used by**: Local long variable loads

### 32-bit Arithmetic (Stubs)

The following functions are declared but not yet implemented:

- `add32` - Add two 32-bit values
- `sub32` - Subtract two 32-bit values
- `and32` - Bitwise AND of two 32-bit values
- `or32` - Bitwise OR of two 32-bit values
- `xor32` - Bitwise XOR of two 32-bit values

**Input convention** (to be implemented):
- HL'HL: First operand
- DE'DE: Second operand

**Output convention** (to be implemented):
- HL'HL: Result

## Register Conventions

### Z80 Register Set

**Primary Accumulator**:
- HL - 16-bit primary (word operations)
- A - 8-bit primary (byte operations)

**Secondary Accumulator**:
- DE - 16-bit secondary
- E - 8-bit secondary

**Allocatable Registers**:
- BC, IX - Word registers (2 bytes)
- B, C, B', C' - Byte registers (1 byte)

**Frame Pointer**:
- IY - Always points to current stack frame

**Alternate Set**:
- Access via `exx` instruction
- HL' - Upper 16 bits of 32-bit longs
- BC', DE' - Alternate register pairs

### Calling Convention

**Function Entry**:
1. `call framealloc` - Allocate stack frame
2. Parameters available at (IY + offset) for stack args
3. Register-allocated parameters in BC/IX/B/C/B'/C'

**Function Exit**:
1. Return value in HL (16-bit) or A (8-bit) or HL'HL (32-bit)
2. `jp framefree` - Deallocate frame and return

**Caller Responsibilities**:
- Push arguments right-to-left onto stack
- Clean up stack after call (if needed)

## Code Generation Examples

### Local Long Variable

```c
long l;
l = 12345L;
return l;
```

**Generated assembly**:
```z80
; Store long constant to local at (IY-4)
ld hl, 12345      ; Low word
exx
ld hl, 0          ; High word
exx
ld a, -4          ; Frame offset
call putlong      ; Store HL'HL at (IY-4)

; Load long from local
ld a, -4          ; Frame offset
call getlong      ; Load into HL'HL
; Return with value in HL'HL
```

### Global Long Variable

```c
long global_long;
global_long = value;
```

**Generated assembly** (optimized, no function call):
```z80
; Assume value in HL'HL
ld ($_global_long), hl      ; Store low word
exx
ld ($_global_long+2), hl    ; Store high word
exx
```

### Local Variable Address

```c
int *p;
int local;
p = &local;
```

**Generated assembly**:
```z80
ld a, -2          ; Offset of 'local'
call leaiy        ; Get address into HL
; Store HL to p...
```

## Memory Layout

### Stack Frame Structure

```
Higher addresses
+------------------+
| Return address   | (IY + 2)
+------------------+
| Old IY           | (IY + 0)  <- IY points here
+------------------+
| Local var 1      | (IY - 1)
+------------------+
| Local var 2      | (IY - 3)
+------------------+
| ...              |
+------------------+
| Local var N      | (IY - frame_size + 1)
+------------------+
| Stack grows down | <- SP
Lower addresses
```

### Long Integer Storage

32-bit longs stored in little-endian format:
```
Address:    +0    +1    +2    +3
Value:     LL    LH    HL    HH
           └─────┘     └─────┘
           Low word    High word
```

Where:
- LL = Low byte of low word
- LH = High byte of low word
- HL = Low byte of high word
- HH = High byte of high word

## Assembly Syntax

The code is written for z80asm assembler with the following conventions:

- Labels end with colon (e.g., `framealloc:`)
- Instructions use tab indentation
- Comments start with semicolon
- Register names in lowercase (a, b, c, de, hl, iy, etc.)
- Hex numbers use 0x prefix or h suffix

## Future Work

1. Implement 32-bit arithmetic functions
2. Add division/modulo helpers (div32, mod32, udiv32, umod32)
3. Add shift helpers (shl32, shr32, sar32)
4. Add multiply helper (mul32)
5. Add comparison helpers (cmp32, ucmp32)
6. Optimize hot paths with inline assembly hints
7. Add floating-point support (if needed)

## References

- Z80 CPU User Manual
- ccc compiler code generator (emit.c, codegen.c)
- AST format documentation (AST_FORMAT.md)
