%{
/*
 * =============================================================================
 * OPTABLE - Z80 Code Generation Tables for Ritchie C Compiler Pass2
 * =============================================================================
 *
 * This file defines pattern-matching rules that drive code generation.
 * cvopt.c processes this file into table.c with encoded patterns.
 *
 * REGISTER MODEL:
 * ---------------
 *   R  (HL)  - Primary accumulator. All expression results end up here.
 *              Also used for function return values (16-bit).
 *   R1 (DE)  - Secondary accumulator. Used for right operand of binops,
 *              or high word of 32-bit values.
 *   R+ (DE)  - High word of long. Longs are stored as HLDE pair:
 *              HL = low 16 bits, DE = high 16 bits.
 *   IY       - Frame pointer. Points to saved IY on stack.
 *              Locals at negative offsets (iy-2, iy-4, ...),
 *              Args at positive offsets (iy+4, iy+6, ...).
 *   BC, IX   - Register variables. Compiler allocates frequently-used
 *              locals to these registers for speed.
 *   SP       - Stack pointer. Grows downward.
 *   A        - Byte accumulator for 8-bit operations.
 *
 * PATTERN SYNTAX - MATCH PREDICATES:
 * ----------------------------------
 * Each rule starts with %<op1>,<op2> defining what operand types match.
 *
 * Operand class specifiers:
 *   z  - Zero constant (literal 0)
 *   c  - Constant (any compile-time constant)
 *   1  - Literal constant 1 (for inc/dec optimization)
 *   a  - Addressible (symbol, stack var, static - can be accessed directly)
 *   e  - Expression in register (already evaluated, result in HL or DE)
 *   r  - Register variable (BC or IX)
 *   n  - aNy (matches everything - wildcard)
 *
 * Type modifiers (follow class specifier):
 *   w  - Word (16-bit int)
 *   b  - Byte (8-bit signed char)
 *   ub - Unsigned byte
 *   l  - Long (32-bit signed)
 *   ul - Unsigned long
 *   f  - Float (32-bit IEEE 754)
 *   d  - Double (same as float in this compiler)
 *   u  - Unsigned (16-bit)
 *   p  - Pointer (adds 16 to type code)
 *
 * Indirection:
 *   *  - Pointer that needs dereferencing. The operand is a pointer,
 *        and we need to load through it to get the actual value.
 *
 * Examples:
 *   %a,n     - Addressible op1, any op2
 *   %aw,aw   - Addressible word op1, addressible word op2
 *   %n*,z    - Any pointer needing deref op1, zero op2
 *   %nub*,n  - Any unsigned-byte pointer needing deref, any op2
 *   %al,nl   - Addressible long, any long
 *
 * PATTERN SYNTAX - OUTPUT CODES:
 * ------------------------------
 * After the match line, indented lines are the output pattern.
 *
 * Operand substitution:
 *   A1  - Emit addressified form of operand 1 (symbol name, (iy+n), etc)
 *   A2  - Emit addressified form of operand 2
 *   R   - Primary register name "hl"
 *   R1  - Secondary register name "de"
 *   I   - Emit instruction from instab (the opcode for this operator)
 *   I'  - Emit instruction with ' variant (e.g., inc vs dec)
 *   Z   - Emit field mask (for bitfield operations)
 *
 * Subtree evaluation:
 *   F   - Evaluate First (left) subtree, result in HL
 *   S   - Evaluate Second (right) subtree, result in HL
 *   F*  - Evaluate First subtree (pointer), then dereference
 *   S*  - Evaluate Second subtree (pointer), then dereference
 *   FS  - Evaluate First subtree for Store (push address for later store)
 *   FS* - Evaluate First subtree pointer, push for later store
 *   SS  - Evaluate Second subtree, push result, continue
 *   F1  - Evaluate First subtree with op1 context
 *   S1  - Evaluate Second subtree with op1 context, result in DE
 *   F1* - Evaluate First subtree pointer with op1 context
 *   S1* - Evaluate Second subtree pointer with op1 context
 *   FC  - Evaluate First subtree for Condition codes
 *   H   - Evaluate for condition codes (cctab handler)
 *
 * Z80-specific smart macros (expanded by c10.c):
 *   Q1  - Smart word load from op1 to HL (handles IY+n, statics, etc)
 *   Q2  - Smart word load from op2 to HL
 *   QD1 - Smart word load from op1 to DE
 *   QD2 - Smart word load from op2 to DE
 *   P1  - Smart word store from HL to op1
 *   P2  - Smart word store from HL to op2
 *   PD1 - Smart word store from DE to op1
 *   PD2 - Smart word store from DE to op2
 *   LA1 - Load Address of op1 into HL
 *   LA2 - Load Address of op2 into HL
 *
 * Branch/jump handling:
 *   X0  - First part of comparison (may short-circuit)
 *   X1  - Second part of comparison
 *   V   - Propagate carry for multi-word arithmetic
 *
 * Labels:
 *   %[name:] - Define a named pattern that can be referenced
 *   %[name]  - Reference a previously defined pattern
 *   name:    - Define a dispatch target label
 *
 * IMPORTANT: Labels must use LOWERCASE letters only!
 * Uppercase letters (A,B,C,F,H,I,L,P,Q,R,S,X,Y,T) are interpreted as
 * output codes by cvopt, so they get consumed instead of added to the
 * label name. Use: rname, radd, rasadd (not rNAME, rADD, rASADD)
 *
 * TABLES:
 * -------
 * This file defines four tables:
 *   regtab  - Generate code for value (result in HL)
 *   efftab  - Generate code for side effect only (result discarded)
 *   cctab   - Generate code and set condition codes for branching
 *   sptab   - Generate code and push result to stack
 *
 * OPERATOR NUMBERS (from c1.h):
 * -----------------------------
 *   14  PTOI    - Pointer difference divided by size
 *   16  FSEL    - Field select (bitfield assignment)
 *   17  DIVIDE  - Integer division
 *   18  MOD     - Integer modulo
 *   28  QUEST   - Ternary operator ?:
 *   30  PREINC  - Prefix ++
 *   31  PREDEC  - Prefix --
 *   32  POSTINC - Postfix ++
 *   33  POSTDEC - Postfix --
 *   34  EXCLA   - Logical NOT !
 *   35  AMPER   - Address-of &
 *   36  STAR    - Dereference *
 *   37  NEG     - Unary minus -
 *   38  COMPL   - Bitwise complement ~
 *   40  PLUS    - Addition +
 *   41  MINUS   - Subtraction -
 *   42  TIMES   - Multiplication *
 *   43  DIVIDE  - Division /
 *   44  MOD     - Modulo %
 *   45  RSHIFT  - Right shift >>
 *   46  LSHIFT  - Left shift <<
 *   48  AND     - Bitwise AND &
 *   49  XOR     - Bitwise XOR ^
 *   51  ITOF    - Int to float conversion
 *   52  FTOI    - Float to int conversion
 *   55  OR      - Bitwise OR |
 *   56  FTOL    - Float to long conversion
 *   57  LTOF    - Long to float conversion
 *   58  ITOL    - Int to long conversion
 *   59  LTOI    - Long to int conversion
 *   60-69       - Comparison operators (==, !=, <, <=, >, >=, signed/unsigned)
 *   70  ASPLUS  - Compound assignment +=
 *   71  ASMINUS - Compound assignment -=
 *   72  ASTIMES - Compound assignment *=
 *   73  ASDIV   - Compound assignment /=
 *   74  ASMOD   - Compound assignment %=
 *   75  ASRSH   - Compound assignment >>=
 *   76  ASLSH   - Compound assignment <<=
 *   78  ASOR    - Compound assignment |=
 *   79  ASXOR   - Compound assignment ^=
 *   80  ASSIGN  - Simple assignment =
 *   81  ANDAND  - Logical AND && (for condition code testing)
 *   82-84       - Long multiply, divide, mod
 *   85  ASAND   - Compound assignment &=
 *   86-88       - Long compound assignment *=, /=, %=
 *   91  LSHIFT (long) - Long left shift
 *   92  ASLSH (long)  - Long compound <<=
 *   98  MCALL   - Member function call
 *   99  CALL    - Function call
 *   102 JUMP    - Goto
 *   106 NAME    - Load name/constant into register
 *   107 PTRDIFF - Pointer difference (int*)-(int*) -> int
 *   109 ITOC    - Int to char conversion (sign extend)
 *   116 STRASG  - Structure assignment setup
 *   117-118     - Unsigned divide/mod
 *   119-120     - Unsigned compound /=, %=
 *   121-126     - Unsigned long *, /, %, *=, /=, %=
 *   127 ULTOF   - Unsigned long to float
 *   128 LUSHR   - Unsigned long right shift
 *   129 ALUSHR  - Unsigned long compound >>=
 */

/*
 * REGTAB - Generate expression value into HL register
 * ----------------------------------------------------
 * This is the main code generation table. Each entry maps an operator
 * number to a code generation rule. The result ends up in HL (or HLDE
 * for 32-bit values).
 */
struct table regtab[] = {
	{LOAD,rname},	/* NAME - load value into register */
	{INCBEF,rasadd},	/* PREINC ++ - uses compound assignment patterns */
	{DECBEF,rasadd},	/* PREDEC -- - uses compound assignment patterns */
	{INCAFT,rpostinc},	/* POSTINC ++ - return old value, then increment */
	{DECAFT,rpostinc},	/* POSTDEC -- - return old value, then decrement */
	{NEG,runary},	/* NEG - unary minus */
	{COMPL,runary},	/* COMPL ~ - bitwise complement */
	{CALL1,rcall},	/* MCALL - member function call */
	{CALL2,rcall},	/* CALL - function call */
	{ASSIGN,rassign},	/* ASSIGN = - simple assignment */
	{PLUS,radd},	/* PLUS + - addition */
	{MINUS,radd},	/* MINUS - - subtraction (uses same patterns as +) */
	{TIMES,rmul},	/* TIMES * - multiplication */
	{DIVIDE,rdiv},	/* DIVIDE / - signed division */
	{PTOI,rptoi},	/* PTOI - pointer difference / sizeof */
	{MOD,rdiv},	/* MOD % - modulo (uses divide patterns) */
	{RSHIFT,rrsh},	/* RSHIFT >> - signed right shift */
	{LSHIFT,radd},	/* LSHIFT << - left shift (uses add patterns) */
	{ANDN,radd},	/* OR | - bitwise or (uses add patterns) */
	{OR,radd},	/* AND & - bitwise and (uses add patterns) */
	{EXOR,rxor},	/* XOR ^ - bitwise xor */
	{ASPLUS,rasadd},	/* ASPLUS += - compound add assignment */
	{ASMINUS,rasadd},	/* ASMINUS -= - compound subtract assignment */
	{ASTIMES,rasmul},	/* ASTIMES *= - compound multiply assignment */
	{ASDIV,rasdiv},	/* ASDIV /= - compound divide assignment */
	{ASMOD,rasmod},	/* ASMOD %= - compound modulo assignment */
	{ASRSH,rasrsh},	/* ASRSH >>= - compound right shift assignment */
	{ASLSH,rasmul},	/* ASLSH <<= - compound left shift assignment */
	{ASOR,rasor},	/* ASOR |= - compound or assignment */
	{ASANDN,rasor},	/* ASAND &= - compound and assignment */
	{ASXOR,rasxor},	/* ASXOR ^= - compound xor assignment */
	{JUMP,rjump},	/* JUMP - goto statement */
	{ITOF,ritof},	/* ITOF - int to float conversion */
	{FTOI,rftoi},	/* FTOI - float to int conversion */
	{FTOL,rftol},	/* FTOL - float to long conversion */
	{LTOF,rltof},	/* LTOF - long to float conversion */
	{ITOL,ritol},	/* ITOL - int to long conversion */
	{LTOI,rltoi},	/* LTOI - long to int conversion */
	{LLSHIFT,rlshl},	/* LSHIFT (long) - 32-bit left shift */
	{LTIMES,rlmul},	/* LTIMES - long multiply */
	{LDIV,rlmul},	/* LDIV - long divide */
	{LMOD,rlmul},	/* LMOD - long modulo */
	{LASTIMES,rlasmul},	/* LASTIMES - long compound *= */
	{LASDIV,rlasmul},	/* LASDIV - long compound /= */
	{LASMOD,rlasmul},	/* LASMOD - long compound %= */
	{FSELA,rfield},	/* FSEL - bitfield assignment */
	{ASLSHL,rlaslsh},	/* ASLSH (long) - long compound <<= */
	{ULSH,rdiv},	/* DIVIDE - uses same as rdiv */
	{ASULSH,rasmod},	/* MOD - uses same as rasmod */
	{ITOC,ritoc},	/* ITOC - int to char (sign extend low byte) */
	{UDIV,rudiv},	/* UDIV - unsigned divide */
	{UMOD,rudiv},	/* UMOD - unsigned modulo */
	{ASUDIV,ruasdiv},	/* UASDIV - unsigned compound /= */
	{ASUMOD,ruasdiv},	/* UASMOD - unsigned compound %= */
	{PTOI1,rptrdif},	/* PTRDIFF - (int*)-(int*) for int pointers */
	{ULTIMES,rulmul},	/* ULTIMES - unsigned long multiply */
	{ULDIV,rulmul},	/* ULDIV - unsigned long divide */
	{ULMOD,rulmul},	/* ULMOD - unsigned long modulo */
	{ULASTIMES,rulasmul},	/* ULASTIMES - unsigned long compound *= */
	{ULASDIV,rulasmul},	/* ULASDIV - unsigned long compound /= */
	{ULASMOD,rulasmul},	/* ULASMOD - unsigned long compound %= */
	{ULTOF,rultof},	/* ULTOF - unsigned long to float */
	{ULLSHIFT,rlushr},	/* LUSHR - unsigned long right shift */
	{UASLSHL,ralushr},	/* ALUSHR - unsigned long compound >>= */
	{0}		/* End of table marker */
};
%}

/*
 * =============================================================================
 * rjump: GOTO - Unconditional jump
 * =============================================================================
 * Generates: jp target
 *
 * Used for: goto label;
 */
rjump:
/*
 * %a,n - Direct jump to addressible label
 * Example: goto label;
 * Output: jp _label
 */
%a,n
	jp	A1

/*
 * %n*,n - Indirect jump through pointer
 * Example: goto *ptr;  (computed goto, GCC extension)
 * First evaluate the pointer expression, then jump through HL.
 * F* = evaluate First subtree and dereference (loads address into HL)
 * Output: jp (hl)
 */
%n*,n
	F*
	jp	(hl)

/*
 * =============================================================================
 * rcall: CALL - Function call
 * =============================================================================
 * Generates: call target
 *
 * Used for: func() or (*fptr)()
 * Arguments are already pushed to stack before this pattern runs.
 * Return value ends up in HL (or HLDE for long/float).
 */
rcall:
/*
 * %a,n - Direct call to addressible function
 * Example: printf("hello");
 * I = instruction prefix (underscore for C symbols)
 * A1 = function name
 * Output: call _printf
 */
%a,n
	call	IA1

/*
 * %n*,n - Indirect call through function pointer (pointer expression)
 * Example: (*fptr)(args);
 * F* = evaluate pointer expression and dereference (loads func addr into HL)
 * jphl = helper routine that does jp (hl) - needed because Z80's
 *        call (hl) doesn't exist, so we call a trampoline.
 * Output:
 *   [code to compute function address into HL]
 *   call jphl
 */
%n*,n
	F*
	call	jphl

/*
 * %n,n - Indirect call through function pointer (already in register)
 * Example: fptr(args); where fptr is a function pointer variable
 * F = evaluate expression (loads func addr into HL)
 * Output:
 *   [code to load function address into HL]
 *   call jphl
 */
%n,n
	F
	call	jphl

/*
 * =============================================================================
 * rname: NAME - Load value into register
 * =============================================================================
 * This is the fundamental "load" operation. It takes any addressible value
 * and loads it into the primary register (HL for 16-bit, HLDE for 32-bit).
 *
 * This rule handles:
 *   - Constants (including zero)
 *   - Global/static variables
 *   - Stack locals (via IY+offset)
 *   - Dereferencing pointers
 *   - Register variables
 */
rname:
/*
 * %z,n - Load zero constant
 * Example: x = 0;
 * R = HL (primary register)
 * Output: ld hl,0
 */
%z,n
	ld	R,0

/*
 * %zf,n - Load float zero
 * Example: float f = 0.0;
 * Uses helper because floats are 32-bit in HLDE/HL' pair.
 * Output: call fclr  (clears float accumulator)
 */
%zf,n
	call	fclr

/*
 * %aub,n - Load addressible unsigned byte
 * Example: unsigned char c; ... use c ...
 * Must zero-extend to 16-bit word in HL.
 * Output:
 *   ld a,(_c)     ; load byte into A
 *   ld l,a        ; move to L
 *   ld h,0        ; zero-extend H
 */
%aub,n
	ld	a,(A1)
	ld	l,a
	ld	h,0

/*
 * %a,n / %ad,n - Load addressible word or double
 * Example: int x; ... use x ...
 * Q1 = smart word load macro - handles all addressing modes:
 *      - Static: ld hl,(_x)
 *      - Stack:  ld l,(iy+n); ld h,(iy+n+1)
 *      - Register: (already in reg, maybe copy)
 * Output: [Q1 expansion for operand 1]
 */
%a,n
%ad,n
	Q1

/*
 * %af,n - Load addressible float
 * Example: float f; ... use f ...
 * Uses helper to load 32-bit float from memory.
 * A1 = address of float variable
 * Output: call fldA1  (loads float from address into HLDE)
 */
%af,n
	call	fldA1

/*
 * %nub*,n - Load through pointer to unsigned byte
 * Example: unsigned char *p; ... *p ...
 * F* = evaluate pointer expression, result is address in HL
 * Then load byte and zero-extend.
 * Output:
 *   [code to get pointer into HL]
 *   ld a,(hl)     ; load byte through pointer
 *   ld l,a        ; move to L
 *   ld h,0        ; zero-extend
 */
%nub*,n
	F*
	ld	a,(hl)
	ld	l,a
	ld	h,0

/*
 * %n*,n / %nd*,n - Load word through pointer
 * Example: int *p; ... *p ...
 * F* = evaluate pointer, address now in HL
 * Load 16-bit value byte-by-byte (Z80 little-endian).
 * Output:
 *   [code to get pointer into HL]
 *   ld a,(hl)     ; load low byte
 *   inc hl        ; point to high byte
 *   ld h,(hl)     ; load high byte into H
 *   ld l,a        ; restore low byte to L
 * Result: 16-bit value now in HL
 */
%n*,n
%nd*,n
	F*
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a

/*
 * %nf*,n - Load float through pointer
 * Example: float *p; ... *p ...
 * F* = evaluate pointer (address in HL)
 * fldi = "float load indirect" helper
 * Output:
 *   [code to get pointer into HL]
 *   call fldi     ; load 32-bit float from (HL) into HLDE
 */
%nf*,n
	F*
	call	fldi

/*
 * %al,n / %aul,n - Load addressible long (32-bit)
 * Example: long x; ... use x ...
 * LA1 = load address of operand 1 into HL
 * Then manually load 4 bytes into HLDE (HL=low, DE=high).
 * Output:
 *   [LA1 - loads address of x into HL]
 *   ld e,(hl)     ; byte 0 -> E (low byte of low word)
 *   inc hl
 *   ld d,(hl)     ; byte 1 -> D (high byte of low word)
 *   inc hl
 *   ld a,(hl)     ; byte 2 -> A (will go to L)
 *   inc hl
 *   ld h,(hl)     ; byte 3 -> H (high byte of high word)
 *   ld l,a        ; byte 2 -> L (low byte of high word)
 *   ex de,hl      ; swap so HL=low word, DE=high word
 * Result: 32-bit value in HLDE (HL=low 16 bits, DE=high 16 bits)
 */
%al,n
%aul,n
	LA1
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ex	de,hl

/*
 * %nl*,n / %nul*,n - Load long through pointer
 * Example: long *p; ... *p ...
 * F* = evaluate pointer (address in HL)
 * lld = "long load" helper - loads 32-bit from (HL) into HLDE
 * Output:
 *   [code to get pointer into HL]
 *   call lld      ; load 32-bit value from (HL)
 */
%nl*,n
%nul*,n
	F*
	call	lld

/*
 * %n,n - Fallback: evaluate any expression
 * Example: complex expression that's not addressible
 * F = evaluate First subtree (result in HL)
 * This is the catch-all that triggers recursive code generation.
 */
%n,n
	F

/*
 * =============================================================================
 * rpostinc: POSTINC/POSTDEC (x++, x--)
 * =============================================================================
 * Postfix increment/decrement: return OLD value, then modify.
 * This is tricky because we must:
 *   1. Save the original value (to return)
 *   2. Compute new value
 *   3. Store new value back
 *   4. Return original value
 *
 * I' = inc or dec instruction depending on operator (++ or --)
 * V = propagate carry/borrow for multi-byte arithmetic
 */
rpostinc:
/*
 * %a,1 - Simple addressible word, increment/decrement by 1
 * Example: x++ where x is a simple variable
 * This is the fast path - Z80 has inc/dec (addr) instructions.
 * Output:
 *   ld hl,(_x)    ; load original value (return this)
 *   inc (_x)      ; or dec (_x) - modify in place
 */
%a,1
	ld	R,(A1)
	I'	(A1)

/*
 * %aw,n - Addressible word, increment by arbitrary amount
 * Example: x += 5 (treated as postfix form)
 * Output:
 *   ld hl,(_x)    ; load original
 *   ld de,5       ; load increment amount
 *   push hl       ; save original for return
 *   [Q1]          ; reload x into HL
 *   add hl,de     ; I = add/sub
 *   [P1]          ; store result back to x
 *   pop hl        ; restore original as return value
 */
%aw,n
	ld	R,(A1)
	ld	de,A2
	push	hl
	Q1
	I
	P1
	pop	hl

/*
 * %aub,n - Addressible unsigned byte
 * Example: char c; c++;
 * Output:
 *   ld a,(_c)     ; load original byte
 *   ld l,a        ; zero-extend to HL
 *   ld h,0
 *   push hl       ; save original
 *   inc a         ; I' = inc or dec
 *   ld (_c),a     ; store new value
 *   pop hl        ; restore original as return
 */
%aub,n
	ld	a,(A1)
	ld	l,a
	ld	h,0
	push	hl
	I'	a
	ld	(A1),a
	pop	hl

/*
 * %e*,1 - Expression pointer to word, inc/dec by 1
 * Example: (*p)++ where p is already computed (in DE)
 * F1* = evaluate pointer with op1 context into DE
 * V = adc a,0 or sbc a,0 to propagate carry to high byte
 * Output:
 *   [F1* - get pointer into DE]
 *   push de               ; save pointer
 *   ex de,hl              ; HL = pointer
 *   ld e,(hl); inc hl; ld d,(hl)  ; load word into DE
 *   ex de,hl              ; HL = original value
 *   ex (sp),hl            ; stack=orig, HL=pointer
 *   ld a,(hl); inc a; ld (hl),a   ; inc low byte
 *   inc hl
 *   ld a,(hl); adc a,0; ld (hl),a ; propagate carry to high
 *   pop hl                ; return original value
 */
%e*,1
	F1*
	push	de
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	(sp),hl
	ld	a,(hl)
	I'	a
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	V	a
	ld	(hl),a
	pop	hl

/*
 * %n*,1 - Any pointer expression, inc/dec by 1
 * Example: (*expr)++
 * F* = evaluate pointer expression into HL
 * Output:
 *   [F* - get pointer into HL]
 *   push hl               ; save pointer
 *   ld e,(hl); inc hl; ld d,(hl)  ; load original into DE
 *   ex (sp),hl            ; stack=orig_value, HL=pointer
 *   ld a,(hl); inc a; ld (hl),a   ; inc low byte
 *   inc hl
 *   ld a,(hl); adc a,0; ld (hl),a ; propagate carry
 *   ex de,hl              ; return original in HL
 */
%n*,1
	F*
	push	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	(sp),hl
	ld	a,(hl)
	I'	a
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	V	a
	ld	(hl),a
	ex	de,hl

/*
 * %ew*,n - Expression pointer to word, inc/dec by n
 * Example: (*p) += 5 as postfix
 * Complex: need to save ptr, load value, save orig, add, store, return orig
 */
%ew*,n
	F1*
	push	de
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ld	de,A2
	ex	(sp),hl
	push	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	I
	ex	de,hl
	pop	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
	pop	hl

/*
 * %eub*,n - Expression pointer to unsigned byte
 * Example: (*p)++ where p points to char
 */
%eub*,n
	F1*
	push	de
	ld	a,(de)
	ld	l,a
	ld	h,0
	ex	(sp),hl
	ld	a,(hl)
	I'	a
	ld	(hl),a
	pop	hl

/*
 * %nw*,n - Any pointer to word, inc/dec by n
 * Example: (*expr) += n as postfix
 */
%nw*,n
	F*
	push	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	push	de
	ld	de,A2
	ld	a,(hl)
	dec	hl
	ld	l,(hl)
	ld	h,a
	I
	ex	de,hl
	pop	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
	pop	hl

/*
 * %nub*,n - Any pointer to unsigned byte
 * Example: (*expr)++ where expr points to char
 */
%nub*,n
	F*
	push	hl
	ld	a,(hl)
	push	af
	I'	a
	ld	(hl),a
	pop	af
	ld	l,a
	ld	h,0
	pop	de

/*
 * %al,1 / %aul,1 - Addressible long, inc/dec by 1
 * Example: long x; x++;
 * Must propagate carry through all 4 bytes.
 * Output:
 *   [F]           ; ?
 *   [Q1]          ; load address into HL
 *   inc hl; inc hl ; point to high word
 *   [inc byte 2, propagate to byte 3]
 *   [load low word as return value]
 */
%al,1
%aul,1
	F
	Q1
	inc	hl
	inc	hl
	ld	a,(hl)
	I'	a
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	V	a
	ld	(hl),a
	dec	hl
	ld	a,(hl)
	dec	hl
	ld	h,(hl)
	ld	l,a

/*
 * %el*,1 / %eul*,1 - Expression pointer to long, inc/dec by 1
 * Example: (*lp)++ where lp is long*
 * Very complex - must handle 32-bit value and carry propagation.
 */
%el*,1
%eul*,1
	F1*
	push	de
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	inc	de
	ld	a,(de)
	inc	de
	push	af
	ld	a,(de)
	pop	bc
	ld	c,a
	push	bc
	push	hl
	pop	de
	pop	hl
	ex	(sp),hl
	inc	hl
	inc	hl
	ld	a,(hl)
	I'	a
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	V	a
	ld	(hl),a
	pop	hl

/*
 * %nl*,1 / %nul*,1 - Any pointer to long, inc/dec by 1
 * Example: (*expr)++ where expr evaluates to long*
 */
%nl*,1
%nul*,1
	F*
	push	hl
	call	lld
	push	hl
	push	de
	ex	(sp),hl
	inc	hl
	inc	hl
	ld	a,(hl)
	I'	a
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	V	a
	ld	(hl),a
	pop	de
	pop	hl

/*
 * =============================================================================
 * runary: NEG (-) and COMPL (~) - Unary operators
 * =============================================================================
 * Unary minus: -x = 0 - x = negate
 * Bitwise complement: ~x = invert all bits
 *
 * I = the appropriate instruction (call neg16 or call com16 for words,
 *     call lneg or call lcom for longs)
 */
runary:
/*
 * %n,n / %nf,n - Negate or complement word/float
 * Example: -x or ~x
 * F = evaluate operand into HL
 * I = neg16 (negate) or com16 (complement) helper call
 * Output:
 *   [code to load x into HL]
 *   call neg16    ; or call com16, or inline for simple cases
 */
%n,n
%nf,n
	F
	I

/*
 * %nl,n / %nul,n - Negate or complement long
 * Example: -longval or ~longval
 * F = evaluate into HLDE (32-bit)
 * I = lneg or lcom helper function
 * Output:
 *   [code to load longval into HLDE]
 *   call lneg     ; or call lcom
 */
%nl,n
%nul,n
	F
	call	I

/*
 * =============================================================================
 * rassign: ASSIGN (=) - Simple assignment
 * =============================================================================
 * Evaluate RHS, store to LHS, return the stored value.
 * The assignment operator returns the value assigned (for chaining: a = b = c).
 *
 * S = evaluate Second (right) operand - the value to assign
 * F* = evaluate First (left) operand as address for storing
 */
rassign:
/*
 * %a,n / %ad,nf - Assign to addressible word or double
 * Example: x = expr;
 * S = evaluate RHS into HL
 * Then store HL to the addressible location.
 * Output:
 *   [code to evaluate RHS into HL]
 *   ld (_x),hl    ; store to variable
 * Result: HL still contains value (for chained assignments)
 */
%a,n
%ad,nf
	S
	ld	(A1),R

/*
 * %aub,n - Assign to addressible unsigned byte
 * Example: char c = expr;
 * S = evaluate RHS into HL (only L is meaningful)
 * Store low byte only.
 * Output:
 *   [code to evaluate RHS into HL]
 *   ld a,l        ; get low byte
 *   ld (_c),a     ; store byte
 */
%aub,n
	S
	ld	a,l
	ld	(A1),a

/*
 * %af,nf - Assign to addressible float
 * Example: float f = expr;
 * S = evaluate RHS into float registers
 * fstA1 = store float to address A1
 */
%af,nf
	S
	call	fstA1

/*
 * %nd*,af - Assign to pointer-to-double from addressible float
 * Example: *dp = floatvar;
 * F* = evaluate destination pointer
 * S = evaluate source float
 * fsti = float store indirect (store to address in HL)
 */
%nd*,af
	F*
	S
	call	fsti

/*
 * %n*,aw - Assign addressible word to pointer location
 * Example: *p = intvar;
 * F* = evaluate destination pointer into HL
 * A2 = load source value directly
 * Store word byte-by-byte (Z80 little-endian).
 * Output:
 *   [code to get dest pointer into HL]
 *   ld de,(_var)  ; load source value
 *   ld (hl),e     ; store low byte
 *   inc hl
 *   ld (hl),d     ; store high byte
 *   ex de,hl      ; return value in HL
 */
%n*,aw
	F*
	ld	de,A2
	ld	(hl),e
	inc	hl
	ld	(hl),d
	ex	de,hl

/*
 * %nf*,af - Assign float through pointer
 * Example: *fp = floatvar;
 */
%nf*,af
	F*
	S
	call	fsti

/*
 * %n*,e - Assign expression (in DE) through pointer
 * Example: *p = expr; where expr is already evaluated
 * F* = evaluate dest pointer into HL
 * S1 = evaluate source into DE
 * Store DE through HL.
 */
%n*,e
	F*
	S1
	ld	(hl),e
	inc	hl
	ld	(hl),d
	ex	de,hl

/*
 * %nub*,e - Assign byte expression through pointer
 * Example: *cp = charexpr;
 * Store only low byte, zero-extend result.
 */
%nub*,e
	F*
	S1
	ld	a,e
	ld	(hl),a
	ld	l,a
	ld	h,0

/*
 * %ed*,nf / %ef*,nf - Assign float to expression pointer
 * Example: *ep = floatexpr; where ep is pointer expression
 * S = evaluate RHS (float) into float regs
 * F1* = evaluate dest pointer into DE
 * fstde = store float to address in DE
 */
%ed*,nf
	S
	F1*
	call	fstde

%ef*,nf
	S
	F1*
	call	fstde

/*
 * %n*,n / %nd*,nf - General pointer assignment
 * Example: *p = expr;
 * FS* = evaluate dest pointer, push it
 * S = evaluate source into HL
 * pop dest address, store HL there.
 * Output:
 *   [code to push dest address]
 *   [code to evaluate source into HL]
 *   pop de        ; get dest address
 *   ld (de),l     ; store low byte
 *   inc de
 *   ld a,h        ; can't do ld (de),h directly
 *   ld (de),a     ; store high byte
 */
%n*,n
%nd*,nf
	FS*
	S
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

/*
 * %nub*,n - Assign byte through general pointer
 */
%nub*,n
	FS*
	S
	pop	de
	ld	a,l
	ld	(de),a

/*
 * %nf*,nf - Assign float through general pointer
 */
%nf*,nf
	FS*
	S
	pop	de
	call	fstde

/*
 * %al,nl ... - Assign long to addressible long
 * Example: long x = longexpr;
 * S = evaluate RHS into HLDE (32-bit)
 * P1 = store low word (HL) to x
 * Q1+2 = load address of x+2 (high word location)
 * Store high word (DE) there.
 */
%al,nl
%al,nul
%aul,nl
%aul,nul
	S
	P1
	Q1+2
	ld	(hl),e
	inc	hl
	ld	(hl),d

/*
 * %el*,nl ... - Assign long through expression pointer
 * Example: *lp = longexpr; where lp is expression
 * S = evaluate RHS (32-bit)
 * F1* = evaluate dest pointer into DE
 * Store all 4 bytes.
 */
%el*,nl
%el*,nul
%eul*,nl
%eul*,nul
	S
	F1*
	ex	de,hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	pop	de
	ld	(hl),e
	inc	hl
	ld	(hl),d
	pop	hl

/*
 * %nl*,nl ... - Assign long through general pointer
 * Example: *p = longexpr;
 * FS* = push dest pointer
 * S = evaluate RHS (32-bit)
 * Use BC as temp for dest pointer to store all 4 bytes.
 */
%nl*,nl
%nl*,nul
%nul*,nl
%nul*,nul
	FS*
	S
	pop	bc
	ld	(bc),l
	inc	bc
	ld	a,h
	ld	(bc),a
	inc	bc
	ld	a,e
	ld	(bc),a
	inc	bc
	ld	a,d
	ld	(bc),a

/*
 * =============================================================================
 * rfield: FSEL - Bitfield assignment
 * =============================================================================
 * Bitfields require read-modify-write: read current value, mask off the
 * field bits, OR in the new value, write back.
 *
 * Z = field mask (inverted) - the bits to preserve
 * The new value is already shifted to the correct position by the compiler.
 */
rfield:
/*
 * %a,n - Assign to addressible bitfield
 * Example: struct.field = val;
 * S = evaluate new value into HL (L has the shifted bits)
 * Read byte, clear field bits with AND, set new bits with OR, write back.
 * Output:
 *   [code to evaluate new value into HL]
 *   ld a,(_struct)  ; read current byte
 *   and 0xF0        ; Z = mask to preserve other bits
 *   or l            ; merge in new field value
 *   ld (_struct),a  ; write back
 */
%a,n
	S
	ld	a,(A1)
	and	Z
	or	l
	ld	(A1),a

/*
 * %e*,n - Bitfield through expression pointer
 * Uses shared pattern [fas1] defined in efftab section.
 */
%e*,n
%	[fas1]

/*
 * %n*,n - Bitfield through general pointer
 * SS = push new value
 * F* = get pointer into HL
 * Do read-modify-write through pointer.
 */
%n*,n
	SS
	F*
	ld	a,(hl)
	pop	de
	and	Z
	or	e
	ld	(hl),a
	ld	l,e
	ld	h,0

/*
 * =============================================================================
 * radd: Binary arithmetic operators (+, -, |, &, <<)
 * =============================================================================
 * These operators share similar code patterns:
 *   - Evaluate left operand into HL
 *   - Evaluate right operand into DE
 *   - Apply operator (add hl,de / or a; sbc hl,de / etc.)
 *   - Result in HL
 *
 * I = the instruction for this operator:
 *     + : add hl,de
 *     - : or a; sbc hl,de
 *     | : call or16
 *     & : call and16
 *     <<: add hl,hl (for shift by 1) or call shl16
 *
 * I' = inc/dec variant for +1/-1 optimization
 */
radd:
/*
 * %n,z - Add/sub zero is identity
 * Example: x + 0, x - 0
 * Just evaluate the operand, result is unchanged.
 */
%n,z
	F

/*
 * %n,1 - Add/sub by 1, use inc/dec
 * Example: x + 1, x - 1
 * F = evaluate into HL
 * I' = inc hl or dec hl
 * Output:
 *   [code to load x into HL]
 *   inc hl        ; or dec hl
 */
%n,1
	F
	I'

/*
 * %[add1:] - NAMED PATTERN: operand + addressible word
 * %n,aw / %nf,ad - Add word from addressible location
 * Example: x + y where y is a simple variable
 * F = evaluate left operand into HL
 * Load right operand directly into DE.
 * I = add/sub/or/and instruction.
 * Output:
 *   [code to load x into HL]
 *   ld de,(_y)    ; load right operand
 *   add hl,de     ; I = the operation
 */
%[add1:]
%n,aw
%nf,ad
	F
	ld	de,A2
	I

/*
 * %[add2:] - operand + expression-pointer-to-word
 * %n,ew* / %nf,ed* - Right operand is dereferenced expression pointer
 * Example: x + *p where p is an expression
 * F = evaluate left operand into HL
 * S1* = evaluate right pointer expression into DE, dereference
 * Load word through pointer, then operate.
 */
%[add2:]
%n,ew*
%nf,ed*
	F
	S1*
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	I

/*
 * %[add3:] - operand + expression (already in register)
 * %n,e / %nf,ef - Right operand already evaluated
 * Example: x + expr where expr is already computed
 * F = evaluate left operand into HL
 * S1 = right operand already in DE
 * Just do the operation.
 */
%[add3:]
%n,e
%nf,ef
	F
	S1
	I

/*
 * %[add4:] - operand + pointer-to-word (needs deref)
 * %n,nw* / %nf,nd* - Right operand is any pointer needing dereference
 * Example: x + *ptr
 * SS* = evaluate right pointer, push it
 * F = evaluate left operand into HL
 * Load through the saved pointer.
 */
%[add4:]
%n,nw*
%nf,nd*
	SS*
	F
	pop	de
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	I

/*
 * %[add5:] - General case: any + any
 * %n,n / %nf,nf - Both operands need full evaluation
 * Example: expr1 + expr2
 * SS = evaluate right operand, push it
 * F = evaluate left operand into HL
 * Pop right operand into DE, operate.
 * Output:
 *   [code to evaluate expr2, push it]
 *   [code to evaluate expr1 into HL]
 *   pop de        ; get right operand
 *   add hl,de     ; I = the operation
 */
%[add5:]
%n,n
%nf,nf
	SS
	F
	pop	de
	I

/*
 * Long addition/subtraction - special handling for 32-bit
 * These patterns handle long + constant, long + unsigned, etc.
 * V = adc/sbc to propagate carry between low and high words.
 */

/*
 * %nl,c / %nul,c / %nl,au / %nul,au - Long + small constant
 * Example: long_val + 5
 * Add to low word, propagate carry to high word.
 * Output:
 *   [code to load long into HLDE]
 *   ld bc,5       ; constant
 *   add hl,bc     ; add to low word
 *   ex de,hl
 *   ld hl,0       ; no carry-in to high word const
 *   adc hl,de     ; V = propagate carry
 *   ex de,hl      ; result in HLDE
 */
%nl,c
%nl,au
%nul,c
%nul,au
	F
	ld	bc,A2
	add	hl,bc
	ex	de,hl
	ld	hl,0
	V
	ex	de,hl

/*
 * %nl,eu / %nul,eu - Long + unsigned expression
 * Example: long_val + unsigned_expr
 */
%nl,eu
%nul,eu
	F
	S1
	add	hl,de
	ex	de,hl
	ld	hl,0
	V
	ex	de,hl

/*
 * %nl,al ... - Long + addressible long
 * Example: long1 + long2 where both are variables
 * Add low words, then high words with carry.
 */
%nl,al
%nl,aul
%nul,al
%nul,aul
	F
	push	de
	QD2
	add	hl,de
	pop	de
	push	hl
	ld	hl,(A2+2)
	ex	de,hl
	V
	ex	de,hl
	pop	hl

/*
 * %[addl1:] - Long + expression long (already in registers)
 * The helper function handles the 32-bit operation.
 */
%[addl1:]
%nl,el
%nl,eul
%nul,el
%nul,eul
	F
	S1
	I

/*
 * %[addl2:] - Long + any long (general case)
 * Must push one operand, evaluate other, call helper.
 * I = ladd (long add), lsub (long sub), lor, land, etc.
 */
%[addl2:]
%nl,nl
%nl,nul
%nul,nl
%nul,nul
	SS
	F
	call	I

/*
 * =============================================================================
 * rxor: XOR (^) - Bitwise exclusive OR
 * =============================================================================
 * XOR needs its own section because Z80 has no 16-bit XOR instruction.
 * Must call helper function xor16.
 */
rxor:
/*
 * %n,e - XOR with expression (already in register)
 * Uses shared [add3] pattern - works the same way.
 */
%n,e
%	[add3]

/*
 * %n,n - General XOR
 * Example: a ^ b
 * FS = evaluate left (but this looks wrong - should be SS?)
 * S = evaluate right into HL
 * Call helper since Z80 can't XOR HL and DE directly.
 */
%n,n
	FS
	S
	pop	de
	call	xor16

/*
 * Long XOR - 32-bit exclusive OR
 */
%nl,el
%nl,eul
%nul,el
%nul,eul
%	[addl1]

%nl,nl
%nl,nul
%nul,nl
%nul,nul
	SS
	F
	call	lxor

/*
 * =============================================================================
 * rrsh: RSHIFT (>>) - Signed right shift
 * =============================================================================
 * Arithmetic right shift preserves sign bit.
 * Z80's SRA instruction does arithmetic shift.
 */
rrsh:
/*
 * %n,1 - Shift right by 1
 * Example: x >> 1
 * F = load value into HL
 * SRA H shifts H right, bit 7 preserved, bit 0 -> carry
 * RR L rotates L right through carry (brings in bit from H)
 * Output:
 *   [code to load x into HL]
 *   sra h         ; arithmetic shift H right
 *   rr l          ; rotate L right through carry
 * Result: HL = x >> 1 with sign preserved
 */
%n,1
	F
	sra	h
	rr	l

/*
 * =============================================================================
 * rmul: TIMES (*) - Multiplication
 * =============================================================================
 * Z80 has no multiply instruction. All multiplication calls helper functions.
 * Uses same patterns as addition since operand handling is identical.
 *
 * I = mul16 (16-bit multiply) or fmul (float multiply)
 */
rmul:
/*
 * %n,aw / %nf,ad - Multiply by addressible operand
 * Uses [add1] pattern - load operands, call mul16.
 */
%n,aw
%nf,ad
%	[add1]

%n,ew*
%nf,ed*
%	[add2]

%n,e
%nf,ef
%	[add3]

%n,n
%nf,nf
%	[add5]

/*
 * =============================================================================
 * rdiv: DIVIDE (/) and MOD (%) - Division operations
 * =============================================================================
 * Z80 has no divide instruction. All division calls helper functions.
 *
 * For integers: I = div16 (signed divide) or mod16 (modulo)
 * For floats: I = fdiv
 *
 * Unlike multiply, divide has specific patterns because:
 * - Division is not commutative (order matters)
 * - Need to call helper functions explicitly
 */
rdiv:
/*
 * %n,aw - Divide by addressible word
 * Example: x / y where y is a variable
 * F = evaluate dividend into HL
 * Load divisor into DE
 * Call divide helper.
 * Output:
 *   [code to load x into HL]
 *   ld de,(_y)
 *   call div16    ; HL = HL / DE, remainder in BC (for mod)
 */
%n,aw
	F
	ld	de,A2
	call	I

/*
 * %n,ew* - Divide by value through expression pointer
 * Example: x / *p where p is an expression
 */
%n,ew*
	F
	S1*
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	call	I

/*
 * %n,e - Divide by expression (already in register)
 */
%n,e
	F
	S1
	call	I

/*
 * %n,n - General divide
 * Example: expr1 / expr2
 */
%n,n
	SS
	F
	pop	de
	call	I

/*
 * Float division - uses same patterns as addition
 */
%nf,ad
%	[add1]

%nf,ed*
%	[add2]

%nf,ef
%	[add3]

%nf,nf
%	[add5]

/*
 * =============================================================================
 * rptoi: PTOI - Pointer difference divided by element size
 * =============================================================================
 * When subtracting two pointers of the same type, C requires the result
 * to be divided by sizeof(element) to give the number of elements between.
 *
 * Example: int *p, *q; ... (p - q) gives element count, not byte count.
 *
 * The subtraction is already done; this just does the division.
 * F! = evaluate with some special flag (difference already computed?)
 */
rptoi:
%nl,a
%nul,a
	F!
	ld	de,A2
	call	div16

/*
 * =============================================================================
 * rasadd: Compound Assignment (+=, -=, |=, &=)
 * =============================================================================
 * Compound assignment operators: x op= y is equivalent to x = x op y
 * but x is only evaluated once (important for side effects).
 *
 * These patterns must:
 *   1. Evaluate RHS into a register
 *   2. Load current LHS value
 *   3. Perform the operation
 *   4. Store result back to LHS
 *   5. Return the new value
 *
 * I = the operation instruction (add hl,de / sbc hl,de / or16 / and16)
 *
 * Named patterns [addqN:] are referenced by other compound operators
 * (*=, /=, etc.) that share the same operand handling.
 */
rasadd:
/*
 * %[addq1:] - Simplest case: addressible word op= addressible word
 * %aw,aw
 * Example: x += y; where both are simple variables
 * Q1 = load x into HL
 * Load y into DE
 * I = operation (add hl,de)
 * P1 = store result back to x
 * Output:
 *   ld hl,(_x)    ; Q1: load LHS
 *   ld de,(_y)    ; load RHS
 *   add hl,de     ; I: operation
 *   ld (_x),hl    ; P1: store result
 * Result: HL = new value
 */
%[addq1:]
%aw,aw
	Q1
	ld	de,A2
	I
	P1

/*
 * %[addq20:] - Unsigned byte op= addressible word
 * %aub,aw
 * Example: unsigned char c; c += x;
 * Must zero-extend byte to word, operate, store byte back.
 */
%[addq20:]
%aub,aw
	ld	a,(A1)
	ld	l,a
	ld	h,0
	ld	de,A2
	I
	ld	a,l
	ld	(A1),a

/*
 * %[addq1a:] - Generic addressible op= addressible
 * %a,aw / %ad,ad
 * Example: x += y;
 * Direct load/operate/store.
 */
%[addq1a:]
%a,aw
%ad,ad
	ld	R,(A1)
	ld	de,A2
	I
	ld	(A1),R

/*
 * %[addq2:] - Addressible word op= pointer-to-word
 * %aw,nw*
 * Example: x += *p;
 * S* = evaluate RHS pointer, dereference
 * Need to save dereferenced value, load LHS, operate, store.
 */
%[addq2:]
%aw,nw*
	S*
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	Q1
	I
	P1
	pop	de

/*
 * %[addq3:] - Addressible word op= any expression
 * %aw,n
 * Example: x += expr;
 * S = evaluate RHS into HL
 * Move to DE, load LHS, operate, store.
 */
%[addq3:]
%aw,n
	S
	ex	de,hl
	Q1
	I
	P1

/*
 * %[addq21:] - Unsigned byte op= any expression
 * %aub,n
 * Example: unsigned char c; c += expr;
 */
%[addq21:]
%aub,n
	SS
	ld	a,(A1)
	ld	l,a
	ld	h,0
	pop	de
	I
	ld	a,l
	ld	(A1),a

/*
 * %[addq4:] - Expression-pointer-to-word op= pointer-to-word
 * %ew*,nw*
 * Example: *p += *q; where p is an expression
 * Very complex: must save both pointers, load values, operate, store.
 */
%[addq4:]
%ew*,nw*
	S*
	F1*
	push	de
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	pop	de
	push	de
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a
	pop	de

/*
 * %[addq4a:] - Addressible double/float op= expression float
 * %ad,ef
 * Example: double d; d += floatexpr;
 * Use float helper functions.
 */
%[addq4a:]
%ad,ef
	call	fldA1
	S1
	I
	call	fstA1

/*
 * %[addq5:] - Generic addressible op= any expression
 * %a,n / %ad,nf
 * Example: x += expr;
 * SS = push RHS
 * Load LHS, pop RHS into DE, operate, store.
 */
%[addq5:]
%a,n
%ad,nf
	SS
	ld	R,(A1)
	pop	de
	I
	ld	(A1),R

/*
 * %[addq6:] - Addressible float op= float expression
 * %af,nf
 * Example: float f; f += floatexpr;
 */
%[addq6:]
%af,nf
	SS
	call	fldA1
	pop	de
	I
	call	fstA1

/*
 * %[addq7:] - Expression-pointer-to-word op= any expression
 * %ew*,n
 * Example: *p += expr; where p is expression
 * S = evaluate RHS
 * F1* = evaluate LHS pointer into DE
 * Load through pointer, operate, store back.
 */
%[addq7:]
%ew*,n
	S
	F1*
	push	hl
	push	de
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

/*
 * %[addq8:] - Any-pointer-to-word op= any expression
 * %nw*,n
 * Example: *ptr += expr;
 * SS = push RHS
 * F* = evaluate LHS pointer
 * Complex register juggling to load, operate, store.
 */
%[addq8:]
%nw*,n
	SS
	F*
	push	hl
	pop	de
	push	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	bc
	ex	(sp),hl
	ex	de,hl
	I
	push	bc
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

/*
 * %[addq9:] - General pointer op= any expression
 * %n*,n
 * Example: *complexexpr += expr;
 * FS* = push LHS pointer
 * SS = push RHS
 * Load through pointer, operate, store back.
 */
%[addq9:]
%n*,n
	FS*
	SS
	pop	hl
	push	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	ex	(sp),hl
	ex	de,hl
	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

/*
 * %[addq22:] - Pointer to unsigned byte op= any expression
 * %nub*,n
 * Example: *charptr += expr;
 * Byte load/store instead of word.
 */
%[addq22:]
%nub*,n
	FS*
	SS
	pop	hl
	ld	a,(hl)
	push	hl
	ld	l,a
	ld	h,0
	pop	de
	ex	(sp),hl
	ex	de,hl
	I
	pop	de
	ld	a,l
	ld	(de),a

/*
 * %[addq9a:] - Pointer to double op= float expression
 * %nd*,nf
 * Example: *doubleptr += floatexpr;
 */
%[addq9a:]
%nd*,nf
	SS
	F*
	push	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	ex	(sp),hl
	ex	de,hl
	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

%[addq10:]
%nf*,nf
	SS
	F*
	push	hl
	call	fldi
	pop	de
	ex	(sp),hl
	ex	de,hl
	I
	pop	de
	call	fstde

%[addq11:]
%al,c
%aul,c
	ld	hl,(A1+2)
	ld	de,A2
	I
	ld	(A1+2),hl
	V	(A1)
	Q1
	ld	de,(A1+2)

%[addq12:]
%al,al
%al,aul
%aul,al
%aul,aul
	ld	hl,(A1+2)
	ld	de,(A2+2)
	I
	ld	(A1+2),hl
	Q1
	QD2
	V
	P1
	ld	de,(A1+2)

%[addq13:]
%al,nl
%al,nul
%aul,nl
%aul,nul
	S
	push	hl
	push	de
	ld	hl,(A1+2)
	ex	(sp),hl
	I
	ld	(A1+2),hl
	pop	hl
	QD1
	V
	P1
	ld	de,(A1+2)

%[addq14:]
%nl*,c
%nul*,c
	F*
	push	hl
	inc	hl
	inc	hl
	ld	de,A2
	push	de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	pop	de
	I
	pop	de
	push	hl
	inc	de
	inc	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a
	dec	de
	dec	de
	dec	de
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	V
	dec	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a
	pop	de

%[addq15:]
%nl*,al
%nl*,aul
%nul*,al
%nul*,aul
	F*
	push	hl
	inc	hl
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ld	de,(A2+2)
	I
	pop	bc
	push	hl
	push	bc
	inc	bc
	inc	bc
	ld	(bc),l
	inc	bc
	ld	a,h
	ld	(bc),a
	pop	hl
	push	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	QD2
	V
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a
	pop	de

%[addq16:]
%nl*,nl
%nl*,nul
%nul*,nl
%nul*,nul
	SS
	F*
	push	hl
	call	lld
	call	ladd
	pop	de
	call	lstde

/* *= */
rasmul:
%a,aw
%ad,ad
%	[addq1a]

%ad,ef
%	[addq4a]

%a,n
%ad,nf
%	[addq5]

%af,nf
%	[addq6]

%aub,aw
%	[addq20]

%aub,n
%	[addq21]

%n*,n
%	[addq9]

%nub*,n
%	[addq22]

%nd*,nf
%	[addq9a]

%nf*,nf
%	[addq10]

/* /= */
rasdiv:
%a,aw
	ld	R,(A1)
	ld	de,A2
	call	I
	ld	(A1),R

%a,n
	SS
	ld	R,(A1)
	pop	de
	call	I
	ld	(A1),R

%aub,n
	SS
	ld	a,(A1)
	ld	l,a
	ld	h,0
	pop	de
	call	I
	ld	a,l
	ld	(A1),a

%e*,n
	SS
	F1*
	push	de
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	pop	de
	ex	(sp),hl
	ex	de,hl
	call	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

%n*,n
	FS*
	SS
	pop	hl
	push	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	ex	(sp),hl
	ex	de,hl
	call	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

%nub*,n
	FS*
	SS
	pop	hl
	ld	a,(hl)
	push	hl
	ld	l,a
	ld	h,0
	pop	de
	ex	(sp),hl
	ex	de,hl
	call	I
	pop	de
	ld	a,l
	ld	(de),a

%ad,ad
%	[addq1a]

%ad,ef
%	[addq4a]

%ad,nf
%	[addq5]

%af,nf
%	[addq6]

%nd*,nf
%	[addq9a]

%nf*,nf
%	[addq10]

/* %= and >>= */
rasmod:
%a,aw
	ld	R,(A1)
	ld	de,A2
	call	I
	ld	(A1),R

%a,n
	SS
	ld	R,(A1)
	pop	de
	call	I
	ld	(A1),R

%aub,n
	SS
	ld	a,(A1)
	ld	l,a
	ld	h,0
	pop	de
	call	I
	ld	a,l
	ld	(A1),a

%e*,n
	SS
	F1*
	push	de
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	pop	de
	ex	(sp),hl
	ex	de,hl
	call	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

%n*,n
	FS*
	SS
	pop	hl
	push	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	ex	(sp),hl
	ex	de,hl
	call	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

%nub*,n
	FS*
	SS
	pop	hl
	ld	a,(hl)
	push	hl
	ld	l,a
	ld	h,0
	pop	de
	ex	(sp),hl
	ex	de,hl
	call	I
	pop	de
	ld	a,l
	ld	(de),a

/* ^= */
rasxor:
%aw,n
%	[addq3]

%ab,n
	SS
	ld	a,(A1)
	ld	l,a
	ld	h,0
	pop	de
	call	xor16
	ld	a,l
	ld	(A1),a

%aub,n
	SS
	ld	a,(A1)
	ld	l,a
	ld	h,0
	pop	de
	call	xor16
	ld	a,l
	ld	(A1),a

%n*,n
	FS*
	pop	hl
	push	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	S
	pop	de
	call	xor16
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

%nub*,n
	FS*
	pop	hl
	ld	a,(hl)
	push	hl
	ld	l,a
	ld	h,0
	S
	pop	de
	call	xor16
	pop	de
	ld	a,l
	ld	(de),a

/* >>= (simple cases) */
rasrsh:
%a,1
	Q1
	sra	h
	rr	l
	P1

%n*,1
	F*
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	sra	d
	rr	e
	ld	(hl),d
	dec	hl
	ld	(hl),e
	ex	de,hl

/* |=, &~= */
rasor:
%aw,aw
%	[addq1]

%aub,a
	ld	a,(A1)
	I	A2
	ld	(A1),a
	ld	l,a
	ld	h,0

%a,aw
%ad,ad
%	[addq1a]

%aw,nw*
%	[addq2]

%aw,n
%	[addq3]

%aub,n
	SS
	ld	a,(A1)
	ld	l,a
	ld	h,0
	pop	de
	I
	ld	a,l
	ld	(A1),a

%ew*,nw*
%	[addq4]

%ad,ef
%	[addq4a]

%a,n
%ad,nf
%	[addq5]

%af,nf
%	[addq6]

%ew*,n
%	[addq7]

%nw*,n
%	[addq8]

%n*,n
%	[addq9]

%nub*,n
	FS*
	SS
	pop	hl
	ld	a,(hl)
	push	hl
	pop	de
	ex	(sp),hl
	I	a
	pop	hl
	ld	(hl),a
	ld	l,a
	ld	h,0

%nd*,nf
%	[addq9a]

%nf*,nf
%	[addq10]

%al,c
%aul,c
%	[addq11]

%al,al
%al,aul
%aul,al
%aul,aul
%	[addq12]

%al,nl
%al,nul
%aul,nl
%aul,nul
%	[addq13]

%nl*,c
%nul*,c
%	[addq14]

%nl*,al
%nl*,aul
%nul*,al
%nul*,aul
%	[addq15]

%nl*,nl
%nl*,nul
%nul*,nl
%nul*,nul
%	[addq16]

/* << for longs */
rlshl:
%nl,aw
%nul,aw
%	[add1]

%nl,ew*
%nul,ew*
%	[add2]

%nl,e
%nul,e
%	[add3]

%nl,nw*
%nul,nw*
%	[add4]

%nl,n
%nul,n
%	[add5]

/* >> for unsigned long */
rlushr:
%nl,n
%nul,n
	SS
	F
	pop	de
	ld	a,e
	call	lushr

/* >>= for unsigned long */
ralushr:
%n,n
	SS
	FS
	pop	de
	ld	a,e
	call	lushr
	pop	de

/* int -> float */
ritof:
%aw,n
	Q1
	call	itof

%nw*,n
	F*
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	call	itof

%n,n
	F
	call	itof

/* float -> int */
rftoi:
%nf,n
	F
	call	ftoi

/* float to long */
rftol:
%nf,n
	F
	call	ftol

/* long to float */
rltof:
%al,n
	Q1
	ld	de,(A1+2)
	call	ltof

%nl*,n
	F*
	call	lld
	call	ltof

%nl,n
	FS
	call	ltof

/* unsigned long to float */
rultof:
%aul,n
	Q1
	ld	de,(A1+2)
	call	ultof

%nul*,n
	F*
	call	lld
	call	ultof

%nul,n
	FS
	call	ultof

/* integer to long */
ritol:
%eu,n
	F1!
	ld	de,0

%nu,n
	F
	ex	de,hl
	ld	hl,0

%e,n
	F1!
	ld	a,d
	rla
	sbc	a,a
	ld	d,a
	ld	e,a

%n,n
	F
	ex	de,hl
	ld	a,d
	rla
	sbc	a,a
	ld	h,a
	ld	l,a

/* long to integer */
rltoi:
%al,n
%aul,n
	Q1

%nl*,n
%nul*,n
	F*
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a

/* *, /, % for longs */
rlmul:
%[l82:]
%nl,nl
%nl,nul
%nul,nl
%nul,nul
	SS
	FS
	call	I

/* *, /, % for unsigned long */
rulmul:
%nul,nl
%nl,nul
%nul,nul
%	[l82]

/* *=, /=, %= for unsigned long */
rulasmul:
%n,nl
%n,nul
%nl,n
%nul,n
%	[l86]

/* *=, /=, %= for longs */
rlasmul:
%[l86:]
%n,nl
%n,nul
	SS
	FS
	call	I

/* convert integer to character (sign extend) */
ritoc:
%n,n
	F
	ld	a,l
	rla
	sbc	a,a
	ld	h,a

/* divide, mod for unsigned */
rudiv:
%n,e
	F!
	S1!
	call	I

%n,n
	SS
	F!
	pop	de
	call	I

/* /= %= for unsigned */
ruasdiv:
%aw,e
%ab,e
	Q1
	S1!
	call	I
	P1

%aub,e
	ld	a,(A1)
	ld	l,a
	ld	h,0
	S1!
	call	I
	ld	a,l
	ld	(A1),a

%aw,n
%ab,n
	SS
	Q1
	pop	de
	call	I
	P1

%nw*,n
%nb*,n
	FS*
	S!
	ex	de,hl
	pop	hl
	push	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	call	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

%aub,n
	SS
	ld	a,(A1)
	ld	l,a
	ld	h,0
	pop	de
	call	I
	ld	a,l
	ld	(A1),a

%nub*,n
	FS*
	S!
	ex	de,hl
	pop	hl
	ld	a,(hl)
	push	hl
	ld	l,a
	ld	h,0
	call	I
	pop	de
	ld	a,l
	ld	(de),a

/* (int *) - (int *) */
rptrdif:
%n,n
	F?
	sra	h
	rr	l

%{
/*
 * =============================================================================
 * EFFTAB - Generate code for SIDE EFFECTS only (result discarded)
 * =============================================================================
 * When an expression appears in a statement context where its value is
 * discarded (e.g., "x = 5;" as a statement, not "y = (x = 5)"), we can
 * generate simpler code that doesn't bother leaving a result in HL.
 *
 * Examples:
 *   x++;           // just increment, don't need result
 *   x = y;         // just store, don't need to return value
 *   x += y;        // just add and store
 *
 * These patterns are often simpler than their regtab counterparts because
 * they don't need to preserve the result.
 *
 * Label naming convention:
 *   eXXX  = "effect" version of operator XXX
 *   [moveN:] = named patterns for different assignment scenarios
 */
struct table efftab[] = {
	{INCBEF,easadd},	/* PREINC ++ */
	{DECBEF,easadd},	/* PREDEC -- */
	{INCAFT,easadd},	/* POSTINC ++ */
	{DECAFT,easadd},	/* POSTDEC -- */
	{ASSIGN,eassign},	/* ASSIGN = */
	{ASPLUS,easadd},	/* ASPLUS += */
	{ASMINUS,easadd},	/* ASMINUS -= */
	{ASOR,easor},	/* ASOR |= */
	{ASXOR,easxor},	/* ASXOR ^= */
	{ASANDN,easor},	/* ASAND &= */
	{ASRSH,easrsh},	/* ASRSH >>= */
	{ASLSH,easlsh},	/* ASLSH <<= */
	{FSELA,efield},	/* FSEL - bitfield */
	{STRSET,estrasg},	/* STRASG - struct assignment */
	{0}
};
%}

/*
 * =============================================================================
 * eassign: Assignment for effect (= where result is discarded)
 * =============================================================================
 * Simpler than rassign because we don't need to leave the value in HL.
 * Many [moveN:] named patterns are defined here and shared by other
 * effect operators.
 */
eassign:
%[move1:]
%a,z
%ad,zf
%aub,z
	ld	(A1),0

%[move2:]
%n*,z
%nd*,zf
%nub*,z
	F*
	ld	(hl),0
	inc	hl
	ld	(hl),0

%[move3:]
%a,aw
%ab,a
%ab,aub
%aub,a
%aub,ab
	ld	hl,A2
	P1

%[move4:]
%ab,n*
%a,nw*
%aub,n*
	S*
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	P1

%[move5:]
%a,n
%aub,n
	S
	P1

%[move6:]
%n*,aw
%nb*,a
%nub*,a
	F*
	ld	de,A2
	ld	(hl),e
	inc	hl
	ld	(hl),d

%[move7:]
%n*,ew*
%nb*,e*
%nub*,e*
	F*
	S1*
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d

%[move8:]
%n*,e
%nub*,e
	F*
	S1
	ld	(hl),e
	inc	hl
	ld	(hl),d

%[move9:]
%e*,nw*
%eb*,n*
%eub*,n*
	S*
	F1*
	push	de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ex	de,hl
	pop	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d

%[move10:]
%e*,n
%eub*,n
	S
	F1*
	ex	de,hl
	ld	(hl),e
	inc	hl
	ld	(hl),d

%[move11:]
%n*,nw*
%nb*,n*
%nub*,n*
	FS*
	S*
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	ld	(hl),e
	inc	hl
	ld	(hl),d

%[move12:]
%n*,n
%nub*,n
	FS*
	S
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

%aw,nf
	S
	call	ftoi
	P1

%ew*,nf
	S
	F1*
	call	ftoi
	ex	de,hl
	ld	(hl),e
	inc	hl
	ld	(hl),d

%al,z
%aul,z
	ld	hl,0
	P1
	ld	(A1+2),hl

%nl*,z
%nul*,z
	F*
	ld	(hl),0
	inc	hl
	ld	(hl),0
	inc	hl
	ld	(hl),0
	inc	hl
	ld	(hl),0

%[move13a:]
%al,aw
%aul,aw
	ld	hl,A2
	P1
	ld	a,h
	rla
	sbc	a,a
	ld	h,a
	ld	l,a
	ld	(A1+2),hl

%al,nw*
%aul,nw*
	S*
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	P1
	ld	a,h
	rla
	sbc	a,a
	ld	h,a
	ld	l,a
	ld	(A1+2),hl

%al,n
%aul,n
	S
	P1
	ld	a,h
	rla
	sbc	a,a
	ld	h,a
	ld	l,a
	ld	(A1+2),hl

%al,nf
%aul,nf
	S
	call	ftol
	P1
	ld	(A1+2),de

%el*,nf
%eul*,nf
	S
	F1*
	call	ftol
	ex	de,hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	pop	de
	ld	(hl),e
	inc	hl
	ld	(hl),d

%[move13:]
%al,al
%al,aul
%aul,al
%aul,aul
	Q2
	P1
	ld	hl,(A2+2)
	ld	(A1+2),hl

%[move14:]
%al,nl*
%al,nul*
%aul,nl*
%aul,nul*
	S*
	call	lldde
	P1
	ld	(A1+2),de

%[move15:]
%al,nl
%al,nul
%aul,nl
%aul,nul
	S
	P1
	ld	(A1+2),de

%[move14a:]
%nl*,aw
%nul*,aw
	F*
	ld	de,A2
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	ld	a,d
	rla
	sbc	a,a
	ld	(hl),a
	inc	hl
	ld	(hl),a

%[move16a:]
%nl*,al
%nl*,aul
%nul*,al
%nul*,aul
	F*
	QD2
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	ld	de,(A2+2)
	ld	(hl),e
	inc	hl
	ld	(hl),d

%[move16:]
%el*,nl
%el*,nul
%eul*,nl
%eul*,nul
	S
	F1*
	ex	de,hl
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	pop	de
	ld	(hl),e
	inc	hl
	ld	(hl),d

%nl*,n
%nul*,n
	SS
	F*
	pop	de
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	ld	a,d
	rla
	sbc	a,a
	ld	(hl),a
	inc	hl
	ld	(hl),a

%[move17:]
%nl*,nl
%nl*,nul
%nul*,nl
%nul*,nul
	SS
	F*
	pop	de
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	pop	de
	ld	(hl),e
	inc	hl
	ld	(hl),d

/* =| and =&~ */
easor:
%a,a
%a,ab
%a,aub
%ab,a
%ab,ab
%ab,aub
%aub,a
%aub,ab
%aub,aub
%	[move3]

%aub,n
	S
	ld	a,l
	I	(A1)
	ld	(A1),a

%a,n
%	[move5]

%n*,aw
%nb*,a
%nub*,a
%	[move6]

%n*,ew*
%nb*,e*
%nub*,e*
%	[move7]

%n*,e
%	[move8]

%e*,nw*
%eb*,n*
%eub*,n*
%	[move9]

%e*,n
%	[move10]

%n*,nw*
%nb*,n*
%nub*,n*
%	[move11]

%n*,n
%	[move12]

%al,c
%al,au
%aul,c
%aul,au
%	[move13a]

%al,al
%al,aul
%aul,al
%aul,aul
%	[move13]

%al,nl*
%al,nul*
%aul,nl*
%aul,nul*
%	[move14]

%al,nl
%al,nul
%aul,nl
%aul,nul
%	[move15]

%nl*,c
%nul*,c
%	[move14a]

%nl*,al
%nl*,aul
%nul*,al
%nul*,aul
%	[move16a]

%el*,nl
%el*,nul
%eul*,nl
%eul*,nul
%	[move16]

%nl*,nl
%nl*,nul
%nul*,nl
%nul*,nul
%	[move17]

/* =^ */
easxor:
%al,nl
%al,nul
%aul,nl
%aul,nul
%	[move15]

%el*,nl
%el*,nul
%eul*,nl
%eul*,nul
%	[move16]

%nl*,nl
%nl*,nul
%nul*,nl
%nul*,nul
	FS*
	S
	pop	bc
	ld	a,(bc)
	xor	l
	ld	(bc),a
	inc	bc
	ld	a,(bc)
	xor	h
	ld	(bc),a
	inc	bc
	ld	a,(bc)
	xor	e
	ld	(bc),a
	inc	bc
	ld	a,(bc)
	xor	d
	ld	(bc),a

/* =+ for effect */
easadd:
%n*,z
%a,z
%ab,1
%aub,1
%a,1
	I'	(A1)

%aw,aw
%	[move3]

%aw,nw*
%	[move4]

%aw,n
%	[move5]

%n*,1
%nub*,1
%	[move2]

%ew*,nw*
%	[move9]

%a,ew*
	S*
	push	de
	Q1
	ld	a,(de)
	inc	de
	ld	d,(de)
	ld	e,a
	I
	P1
	pop	de

%a,n
	S
	ex	de,hl
	Q1
	I
	P1

%aub,n
	S
	ld	a,(A1)
	I	l
	ld	(A1),a

%ew*,n
%	[move10]

%nw*,n
%	[move12]

%n*,n
	SS
	F*
	push	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	pop	de
	ex	(sp),hl
	ex	de,hl
	I
	pop	de
	ld	(de),l
	inc	de
	ld	a,h
	ld	(de),a

%nub*,n
	SS
	F*
	ld	a,(hl)
	push	hl
	push	af
	pop	hl
	ld	h,0
	pop	de
	ex	(sp),hl
	ex	de,hl
	I
	pop	de
	ld	a,l
	ld	(de),a

%al,c
%al,au
%aul,au
%aul,c
%	[move13a]

%al,al
%al,aul
%aul,al
%aul,aul
%	[move13]

%al,nl*
%al,nul*
%aul,nl*
%aul,nul*
%	[move14]

%al,nl
%al,nul
%aul,nl
%aul,nul
%	[move15]

%nl*,c
%nl*,au
%nul*,c
%nul*,au
%	[move14a]

%nl*,al
%nl*,aul
%nul*,al
%nul*,aul
%	[move16a]

%el*,nl
%el*,nul
%eul*,nl
%eul*,nul
%	[move16]

%nl*,nl
%nl*,nul
%nul*,nl
%nul*,nul
%	[move17]

/* >>= (simple) */
easrsh:
%a,1
	Q1
	sra	h
	rr	l
	P1

%aub,1
	ld	a,(A1)
	srl	a
	ld	(A1),a

%n*,1
	F*
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	sra	d
	rr	e
	ld	(hl),d
	dec	hl
	ld	(hl),e

%nub*,1
	F*
	ld	a,(hl)
	srl	a
	ld	(hl),a

/* <<= */
easlsh:
%a,1
%aub,1
	Q1
	add	hl,hl
	P1

%n*,1
%nub*,1
	F*
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	add	hl,hl
	ex	de,hl
	ld	(hl),d
	dec	hl
	ld	(hl),e

%r,aw
	Q1
	ld	a,A2
	call	shl16

%r,nw*
	S*
	ld	a,(de)
	Q1
	call	shl16
	P1

%r,n
	S
	ld	a,l
	Q1
	call	shl16
	P1

/* <<= for longs */
rlaslsh:
%al,aw
%aul,aw
	Q1
	ld	de,(A1+2)
	ld	a,A2
	call	lshl
	P1
	ld	(A1+2),de

%al,n
%aul,n
	SS
	Q1
	ld	de,(A1+2)
	pop	bc
	ld	a,c
	call	lshl
	P1
	ld	(A1+2),de

%nl*,n
%nul*,n
	FS*
	SS
	pop	hl
	push	hl
	call	lld
	pop	bc
	ld	a,c
	call	lshl
	pop	de
	call	lstde

/* field = ... */
efield:
%a,a
	ld	a,(A1)
	and	Z
	ld	hl,A2
	or	l
	ld	(A1),a

%a,n
	S
	ld	a,(A1)
	and	Z
	or	l
	ld	(A1),a

%n*,a
	F*
	ld	a,(hl)
	and	Z
	ld	de,A2
	or	e
	ld	(hl),a

%[fas1:]
%e*,n
	S
	F1*
	ld	a,(de)
	and	Z
	or	l
	ld	(de),a

%n*,e
	F*
	S1
	ld	a,(hl)
	and	Z
	or	e
	ld	(hl),a

%n*,n
	SS
	F*
	pop	de
	ld	a,(hl)
	and	Z
	or	e
	ld	(hl),a

%{
/*
 * =============================================================================
 * CCTAB - Generate code that SETS CONDITION CODES for branching
 * =============================================================================
 * Used in conditional contexts: if(), while(), for(), ?:
 *
 * The generated code must set the Z80 flags appropriately:
 *   - Zero flag (Z): set if result is zero
 *   - Sign flag (S): set if result is negative
 *   - Carry flag (C): set for unsigned comparisons
 *
 * After these patterns execute, the caller uses conditional jumps:
 *   jp z,label   - jump if zero/equal
 *   jp nz,label  - jump if not zero/not equal
 *   jp c,label   - jump if carry (unsigned less than)
 *   jp m,label   - jump if minus (signed negative)
 *
 * For comparisons (==, !=, <, <=, >, >=), the pattern does:
 *   or a        ; clear carry
 *   sbc hl,de   ; subtract, setting flags
 *
 * Label naming convention:
 *   cXXX = "condition code" version of operator XXX
 *   rest = fallback - just evaluate expression and set codes
 *
 * Long comparisons use X0/X1 for short-circuit evaluation:
 *   Compare low words first (X0), if equal compare high words (X1).
 */
struct table cctab[] = {
	{LOAD,ccmp},	/* NAME - compare/test value */
	{AUTOD,rest},	/* QUEST ?: - evaluate for condition */
	{ANDN,rest},	/* OR | - evaluate for condition */
	{EXCLA,rest},	/* EXCLA ! - evaluate for condition */
	{AMPER,rest},	/* AMPER & - evaluate for condition */
	{STAR,rest},	/* STAR * - evaluate for condition */
	{NEG,rest},	/* NEG - - evaluate for condition */
	{PLUS,rest},	/* PLUS + - evaluate for condition */
	{MINUS,rest},	/* MINUS - - evaluate for condition */
	{DIVIDE,rest},	/* DIVIDE / - evaluate for condition */
	{TAND,candtst},	/* ANDAND && - bitwise AND test (a&b)==0 */
	{OR,rest},	/* AND & - evaluate for condition */
	{EQUAL,ccmp},	/* EQ == */
	{NEQUAL,ccmp},	/* NE != */
	{LESSEQ,ccmp},	/* LT < (signed) */
	{LESS,ccmp},	/* LE <= (signed) */
	{GREATEQ,ccmp},	/* GT > (signed) */
	{GREAT,ccmp},	/* GE >= (signed) */
	{LESSEQP,ccmp},	/* LO < (unsigned) */
	{LESSP,ccmp},	/* LS <= (unsigned) */
	{GREATQP,ccmp},	/* HI > (unsigned) */
	{GREATP,ccmp},	/* HS >= (unsigned) */
	{ASTIMES,rest},	/* ASTIMES *= - evaluate for condition */
	{ASDIV,rest},	/* ASDIV /= - evaluate for condition */
	{ASXOR,rest},	/* ASXOR ^= - evaluate for condition */
	{0}
};
%}

/*
 * =============================================================================
 * ccmp: Comparison and relational operators for condition codes
 * =============================================================================
 * Generate code that sets Z80 flags for conditional branching.
 * These patterns compare two values and leave flags set for jp z/nz/c/nc/m/p.
 */
ccmp:
%a,z
%ad,zf
%aub,z
	Q1
	ld	a,h
	or	l

%af,z
	call	fldA1
	call	ftst

%n*,z
%nd*,zf
%nub*,z
	F*
	ld	a,(hl)
	inc	hl
	or	(hl)

%nf*,z
	F*
	call	fldi
	call	ftst

%n,z
%nf,zf
	FC

%aw,aw
%ab,ab
%aub,a
%aub,aub
	Q1
	QD2
	or	a
	sbc	hl,de

%nw*,aw
%nb*,ab
%nub*,aub
	F*
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	de,A2
	or	a
	sbc	hl,de

%n,aw
%nf,ad
%	[add1]

%nw*,ew*
%nb*,eb*
%nub*,eub*
	F*
	S1*
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	or	a
	sbc	hl,de

%nw*,e
	F*
	S1
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	or	a
	sbc	hl,de

%n,ew*
%nf,ed*
%	[add2]

%n,e
%nf,ef
%	[add3]

%nw*,nw*
%nb*,nb*
%nub*,nub*
	FS*
	S*
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	or	a
	sbc	hl,de

%nw*,n
	FS*
	S
	pop	de
	ld	a,(de)
	inc	de
	push	af
	ld	a,(de)
	pop	de
	ld	d,a
	or	a
	sbc	hl,de

%n,n
%nf,nf
%	[add5]

%al,z
%aul,z
	Q1
	ld	a,h
	or	l
	X0
	ld	hl,(A1+2)
	ld	a,h
	or	l
	X1

%al,c
%al,au
%aul,c
%aul,au
	Q1
	ld	a,h
	or	l
	X0
	ld	hl,(A1+2)
	ld	de,A2
	or	a
	sbc	hl,de
	X1

%[lcmp1:]
%al,al
%al,aul
%aul,al
%aul,aul
	Q1
	QD2
	I
	X0
	ld	hl,(A1+2)
	ld	de,(A2+2)
	I
	X1

%nl*,z
%nul*,z
	F*
	ld	a,(hl)
	inc	hl
	or	(hl)
	inc	hl
	X0
	ld	a,(hl)
	inc	hl
	or	(hl)
	X1

%nl*,c
%nul*,c
%nl*,au
%nul*,au
	F*
	ld	a,(hl)
	inc	hl
	or	(hl)
	inc	hl
	X0
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	de,A2
	or	a
	sbc	hl,de
	X1

%[lcmp2:]
%nl*,al
%nl*,aul
%nul*,al
%nl*,aul
	F*
	push	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	Q2
	ex	de,hl
	I
	X0
	pop	hl
	inc	hl
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	hl,(A2+2)
	ex	de,hl
	I
	X1

%nl,z
%nul,z
	F
	ld	a,h
	or	l
	X0
	ld	a,d
	or	e
	X1

%nl,c
%nul,c
%nl,au
%nul,au
	F
	ld	a,h
	or	l
	X0
	ld	hl,A2
	ex	de,hl
	or	a
	sbc	hl,de
	X1

%[lcmp3:]
%nl,al
%nl,aul
%nul,al
%nul,aul
	F
	push	de
	QD2
	I
	X0
	pop	hl
	ld	de,(A2+2)
	I
	X1

%[lcmp4:]
%nl*,el*
%nl*,eul*
%nul*,el*
%nul*,eul*
	F*
	S1*
	push	hl
	push	de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	pop	hl
	push	de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	pop	hl
	I
	X0
	pop	hl
	pop	de
	inc	hl
	inc	hl
	inc	de
	inc	de
	push	hl
	push	de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	pop	hl
	push	de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	pop	hl
	I
	X1

%[lcmp5:]
%nl,el*
%nl,eul*
%nul,el*
%nul,eul*
	F
	S1*
	push	hl
	push	de
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	I
	X0
	pop	hl
	inc	de
	inc	de
	push	de
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	de
	I
	X1

%[lcmp6:]
%nl,nl
%nl,nul
%nul,nl
%nul,nul
	FS
	S
	pop	de
	I
	X0
	pop	de
	I
	X1

/* & as in "if ((a&b)==0)" */
candtst:
%a,a
%a,ab
%a,aub
%ab,a
%ab,ab
%ab,aub
%aub,a
%aub,ab
%aub,aub
	Q1
	ld	de,A2
	ld	a,l
	and	e
	ld	l,a
	ld	a,h
	and	d
	or	l

%a,e
%aub,e
	S
	QD1
	ld	a,l
	and	e
	ld	l,a
	ld	a,h
	and	d
	or	l

%n*,a
%nu*,a
%nub*,a
	F*
	ld	de,A2
	ld	a,(hl)
	and	e
	ld	e,a
	inc	hl
	ld	a,(hl)
	and	d
	or	e

%n,a
%	[add1]

%n,e
%	[add3]

%n,n
%	[add5]

%al,c
%aul,c
%al,au
%aul,au
	ld	hl,(A1+2)
	ld	de,A2
	ld	a,l
	and	e
	ld	l,a
	ld	a,h
	and	d
	or	l
	X1

%nl*,c
%nul*,c
%nl*,au
%nul*,au
	F*
	inc	hl
	inc	hl
	ld	de,A2
	ld	a,(hl)
	and	e
	ld	e,a
	inc	hl
	ld	a,(hl)
	and	d
	or	e
	X1

%al,al
%al,aul
%aul,al
%aul,aul
%	[lcmp1]

%nl*,al
%nl*,aul
%nul*,al
%nul*,aul
%	[lcmp2]

%nl,al
%nl,aul
%nul,al
%nul,aul
%	[lcmp3]

%nl*,el*
%nl*,eul*
%nul*,el*
%nul*,eul*
%	[lcmp4]

%nl,el*
%nl,eul*
%nul,el*
%nul,eul*
%	[lcmp5]

%nl,nl
%nl,nul
%nul,nl
%nul,nul
%	[lcmp6]

%nl,c
%nul,c
%nl,au
%nul,au
	F
	ld	hl,A2
	ld	a,l
	and	e
	ld	l,a
	ld	a,h
	and	d
	or	l
	X1

/* set codes right */
rest:
%n,n
%nf,nf
	H

%{
/*
 * =============================================================================
 * SPTAB - STACK PUSH TABLES
 * =============================================================================
 *
 * Purpose: Generate code to evaluate an expression and push the result onto
 * the stack. This is used for:
 *   - Function arguments (pushed right-to-left before CALL)
 *   - Compound operations that need to save intermediate values
 *   - Long (32-bit) operations that use stack-based helpers
 *
 * How sptab differs from regtab:
 *   - regtab: evaluate expression, leave result in HL (or A for bytes)
 *   - sptab: evaluate expression, result ends up on stack (via PUSH HL)
 *
 * Stack Growth:
 *   Z80 stack grows downward (SP decreases on PUSH)
 *   PUSH HL: SP -= 2, then store HL at (SP)
 *   For 32-bit values: push high word first, then low word
 *   Result: low word at lower address (little-endian in memory)
 *
 * Dispatch Table Opcodes:
 *   106 = NAME     - Push named variable or constant
 *   40  = ADD      - Push result of addition (also -, |, &~)
 *   41  = SUB      - Push result of subtraction
 *   55  = OR       - Push result of bitwise OR
 *   48  = AND_NOT  - Push result of AND-NOT
 *   58  = ITOL     - Convert int to long, push 32-bit result
 *   56  = FTOL     - Convert float to long, push 32-bit result
 *
 * Label Naming:
 *   sname  - Push named value (variable, constant)
 *   sadd   - Push binary arithmetic result
 *   sitol  - Push int converted to long (4 bytes)
 *   sftol  - Push float as long (reinterpret bits)
 *
 * Common Patterns:
 *   Q1; push hl           - Load word, push it
 *   ld hl,(A1+2); push hl; Q1; push hl  - Load 32-bit, push both words
 *   FS; I' (sp)           - Eval both, apply op to stack top
 *
 * Note: Most expressions go through regtab with explicit PUSH added by caller.
 * sptab provides optimized patterns for common "evaluate and push" sequences.
 * =============================================================================
 */

struct table sptab[] = {
	{LOAD,sname},
	{PLUS,sadd},
	{MINUS,sadd},
	{ANDN,sadd},
	{OR,sadd},
	{ITOL,sitol},
	{FTOL,sftol},
	{0}
};
%}

/*
 * -----------------------------------------------------------------------------
 * sname - Push Named Value to Stack
 * -----------------------------------------------------------------------------
 * Handle NAME nodes (variables, constants) by loading value and pushing.
 * Used for function arguments and compound operations needing stack storage.
 *
 * Pattern types:
 *   %z,n    - Zero constant: push 0
 *   %aw,n   - Addressable word: load and push
 *   %aub,n  - Addressable unsigned byte: zero-extend and push as word
 *   %nw*,n  - Word through pointer: deref pointer, load word, push
 *   %al,n   - Addressable long: push high word, then low word (4 bytes total)
 * -----------------------------------------------------------------------------
 */
sname:
/* Zero constant (int or float) - push 0 */
%z,n
%zf,n
	ld	hl,0
	push	hl

/* Addressable word variable - smart load and push */
%aw,n
	Q1
	push	hl

/* Addressable unsigned byte - zero-extend to word and push */
/* Result on stack is 16-bit with high byte = 0 */
%aub,n
	ld	a,(A1)
	ld	l,a
	ld	h,0
	push	hl

/* Word through pointer - eval pointer in HL, deref, push word */
/* Pattern: F* gives us pointer in HL, then we load word at (HL) */
%nw*,n
	F*
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl

/* Addressable long (signed or unsigned) - push as 32-bit (2 words) */
/* Push order: high word first, then low word */
/* Stack layout after: [low_word] <- SP, [high_word] <- SP+2 */
%al,n
%aul,n
	ld	hl,(A1+2)
	push	hl
	Q1
	push	hl

/*
 * -----------------------------------------------------------------------------
 * sadd - Binary Arithmetic to Stack
 * -----------------------------------------------------------------------------
 * Evaluate binary operation (+, -, |, &~) and push result to stack.
 * Used when function argument is a computed expression, not just a variable.
 *
 * Opcode reuse: opcodes 40 (ADD), 41 (SUB), 55 (OR), 48 (AND_NOT) all route
 * here because the pattern is the same - only the 'I' instruction differs.
 *
 * Key optimization: %a,1 pattern uses I' (sp) to operate directly on stack
 * top without popping, very efficient for increment/decrement of arg.
 * -----------------------------------------------------------------------------
 */
sadd:
/* Any + constant 1: use in-place increment on stack top */
/* FS pushes left operand, then I' operates on (sp) directly */
%a,1
	FS
	I'	(sp)

/* Any + addressable word: push left, load right into DE, pop left, operate */
%a,aw
	FS
	ld	de,A2
	pop	hl
	I
	push	hl

/* Any + word through pointer: complex sequence to get both operands */
/* Push left, eval right pointer, push it, deref to get word, operate */
%a,nw*
	FS
	S*
	push	hl
	ex	de,hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ex	de,hl
	pop	hl
	ex	(sp),hl
	I
	push	hl

/* General case: push left, eval right, pop left into DE, operate, push */
/* Uses ex (sp),hl to swap HL with stack top efficiently */
%a,n
	FS
	S
	pop	de
	ex	(sp),hl
	I
	push	hl

/*
 * -----------------------------------------------------------------------------
 * sitol - Integer to Long, Push to Stack
 * -----------------------------------------------------------------------------
 * Convert 16-bit integer to 32-bit long and push both words to stack.
 * Used when passing int to function expecting long argument.
 *
 * Sign extension for signed:
 *   - RLA rotates sign bit into carry
 *   - SBC A,A produces 0x00 (positive) or 0xFF (negative)
 *   - High word is sign-extended copy
 *
 * Stack layout after: [low_word] <- SP, [high_word] <- SP+2
 * -----------------------------------------------------------------------------
 */
sitol:
/* Unsigned integer: push already on stack, just add zero high word */
%nu,n
	FS
	ld	hl,0
	push	hl

/* Signed word: load, sign-extend to 32 bits, push both words */
/* RLA gets sign bit into carry, SBC A,A gives 0x00 or 0xFF */
%aw,n
	Q1
	ld	a,h
	rla
	sbc	a,a
	ld	d,a
	ld	e,a
	push	de
	push	hl

/*
 * -----------------------------------------------------------------------------
 * sftol - Float to Long, Push to Stack
 * -----------------------------------------------------------------------------
 * Convert 32-bit float to 32-bit long and push result.
 * Uses ftol helper function which returns result in DE:HL (high:low).
 * Float is already 32 bits, so this is really a type conversion.
 * -----------------------------------------------------------------------------
 */
sftol:
/* Float expression: evaluate, call ftol helper, push 32-bit result */
%nf,n
	F
	call	ftol
	push	de
	push	hl

/*
 * -----------------------------------------------------------------------------
 * estrasg - Structure Assignment Setup
 * -----------------------------------------------------------------------------
 * Prepare for structure assignment by loading source address.
 * The F! output code loads the first operand's ADDRESS (not value).
 * Used before block copy operations like LDIR.
 *
 * Note: This is in efftab (effect table) despite the 's' prefix label,
 * because structure assignment is done for side effect, not value.
 * The label name 'estrasg' reflects its purpose (structure assignment).
 * -----------------------------------------------------------------------------
 */
estrasg:
/* Left is source struct, right is constant size: load addresses for LDIR */
/* F! loads source address, S1! loads dest address and size */
%n,e
	F!
	S1!

/* Left is source, right is expression (computed size): push dest, load source */
/* SS pushes right operand (size or dest), F! loads source address */
%n,n
	SS
	F!
	pop	de

