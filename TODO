## Completed Features (Pass 1)

- ✓ Full C preprocessor (macros, includes, conditional compilation, stringify, token pasting)
- ✓ Nested macro expansion works correctly
- ✓ Complete lexical analysis
- ✓ Type system (primitives, pointers, arrays, functions, structs, unions, enums)
- ✓ Declaration parsing (K&R and ANSI-style functions)
- ✓ ANSI-style function definitions: `int foo(int x) { }` works correctly
- ✓ Function type normalization: parameter names don't affect type compatibility
- ✓ Forward declarations with different parameter names
- ✓ Function parameters stored in namespace at level 2 with V_FUNARG flag
- ✓ Expression parsing with constant folding
- ✓ Statement parsing (all control flow)
- ✓ Typedef support including scoped typedefs inside functions
- ✓ Forward struct/union declarations
- ✓ Bitfield support in struct declarations
- ✓ Local variable declarations inside functions
- ✓ Comprehensive test suite (95+ tests)

## Known Limitations (Pass 1)

- The 'signed' keyword is deliberately not supported
- Anonymous enums may have issues (needs verification)

## TODO (Pass 1 Remaining Work)

- Test and fix anonymous enum declarations if broken
- Improve error messages and recovery
- Type checking and compatibility validation
- Symbol table integration for expression type checking

## TODO (Pass 2 - Code Generation)

- Implement code generator
- Implement assembler output
- Object file generation

## Future Optimizations (Ideas for Later)

### Lexer Optimization
Make a bitmap with 128 entries for character classification:
- 0x01 - character that may start a symbol name
- 0x02 - character internal to a symbol name
- 0x04 - whitespace
- 0x10 - operator
- 0x20 - += kind of operator
- 0x40 - ++ kind of operator

### Code Generation Optimization
Single-bit bitfields in structs for efficient flag handling.
Example: if (sym->visible) { emit("extern "); }
Could generate: ld iy, sym ; bit 4, (iy+9) ; jr foo

### Symbol Table Optimization
Faster/smaller scope and symbol space management:
- Store symbols in array indexed by number instead of pointers
- Index 0 is first global (grows up), locals are negative (grow down)
- Each symbol has scope level (increment on block open, decrement on close)
- Lookups start from most recent local to last global
- Store names as fixed-length strings with hash, length, and data
- Limit name storage to ~12 bytes to get symbol table down to 16 bytes per entry
- Statics: global storage but scoped, with synthetic global name for symbol table
